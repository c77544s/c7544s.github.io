<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM</title>
      <link href="/2023/05/13/%E5%90%8E%E7%AB%AF/Java/JVM/JVM/"/>
      <url>/2023/05/13/%E5%90%8E%E7%AB%AF/Java/JVM/JVM/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，<strong>最大堆内存占用物理内存的1&#x2F;4</strong>，如果应用程序超过该上限，则会抛出 OutOfMemoryError 异常。<strong>初始堆内存大小为物理内存的1&#x2F;64</strong>，但当初始堆内存最小为8MB，则为8MB。</p><h2 id="为什么要分新生代和老年代"><a href="#为什么要分新生代和老年代" class="headerlink" title="为什么要分新生代和老年代"></a>为什么要分新生代和老年代</h2><p>Minor GC——新生代 GC<br>Major GC——老年代GC</p><ol><li>绝大多数对象都是朝生夕灭的，用小范围但高频的 minor gc 去处理这些对象</li><li>熬过越多次垃圾收集过程的对象就越难以销往，低频</li><li>跨代引用相对于同代引用来说仅仅占少数<ol><li>正是因为只占少数，所以不应该为了为了这些少量的跨代引用而区扫描整个老年代，也不能浪费空间让每个对象都记录它是否存在跨代引用，所以为了解决这个问题只需要在新生代建立一个全局的数据结构叫做：记忆集（ Remembered Set ），这个结构把老年代划分成若干小块，并标识哪块内存存在跨代引用，后续新生代发生 gc 时，只有包含了跨代引用的小内存区域才会被加入到 GC Roots 进行扫描</li></ol></li></ol><h2 id="GC-线程如何与用户线程并行"><a href="#GC-线程如何与用户线程并行" class="headerlink" title="GC 线程如何与用户线程并行"></a>GC 线程如何与用户线程并行</h2><p><img src="http://qiniu.c77544s.top/picgo/202305151403370.png" alt="image.png"></p><p>CMS</p><ul><li><p>初始标记</p><ul><li>寻找所有的 GC Root 直接关连的对象，需要 STW，不过这步停顿时间很短</li></ul></li><li><p>并发标记</p><ul><li>三色标记法：下图中，白色代表还没经过标记，灰色是正在标记，黑色是标记过。如果一轮标记完之后还是白色的，代表是垃圾。 </li><li>这个过程中会出现下述问题：<ul><li>浮动垃圾：比如正在标记 C，这时 B 被释放了，结果 C 被成功标记</li><li>对象消失：扫描过 A 之后，A 又引用别的对象，这个对象可能标记不到而被认为是垃圾</li></ul></li><li><img src="http://qiniu.c77544s.top/picgo/202305151420733.png" alt="image.png"></li></ul></li><li><p>重新标记</p><ul><li>为了解决并发标记中存在的问题</li><li>需要STW</li><li><img src="http://qiniu.c77544s.top/picgo/202305151428953.png" alt="image.png"></li></ul></li><li><p>并发删除</p></li></ul><p><img src="http://qiniu.c77544s.top/picgo/202305151433687.png" alt="image.png"></p><p>GC-root 是如何枚举的？<br> hotspot 引入了 <strong>普通对象指针（Ordinary Object Pointer）</strong> 的概念，</p><p>GC 是如何处理跨代引用的？<br>跨代引用假说：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的<br><a href="https://blog.csdn.net/m0_46690280/article/details/121941158">(4条消息) 面试篇之JVM（GC 可达性分析 回收算法 卡表 G1）_g1 卡表实现_Ybb_studyRecord的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka笔记</title>
      <link href="/2023/05/12/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/12/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Kafka 的优点：</p><ol><li>吞吐量高，性能好</li><li>伸缩性好，支持在线水平扩展</li><li>容错性和可靠性</li><li>与大数据生态紧密结合，可无缝对接 haddop、strom、spark 等</li></ol><h2 id="现有的消息模型"><a href="#现有的消息模型" class="headerlink" title="现有的消息模型"></a>现有的消息模型</h2><h3 id="JMS-规范"><a href="#JMS-规范" class="headerlink" title="JMS 规范"></a>JMS 规范</h3><p>Java 中的规范，最常见的就是 Apache ActiveMQ</p><h3 id="AMQP-模型"><a href="#AMQP-模型" class="headerlink" title="AMQP 模型"></a>AMQP 模型</h3><ul><li>队列（queues）</li><li>信箱（exchanges）</li><li>绑定（bingdings）<br>特点：支持事务、数据一致性高，多用于银行、金融行业<br>常见的实现： RabbitMQ</li></ul><h3 id="MQTT-模型"><a href="#MQTT-模型" class="headerlink" title="MQTT 模型"></a>MQTT 模型</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）<br>MQTT 是一种基于客户端服务端架构的发布&#x2F;订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>Topic 主题<ul><li>类似于数据库中的表，属于半结构化</li></ul></li><li>Partition 分区<ul><li>topic 可拆分成多个分区，不同分区放在不同服务器上，使得 Kafka 扩展性很好 </li><li>分区是一个线性增长的不可变的提交日志，分区中的每个消息都有一个偏移量 offset，同一个分区的 offset 递增不可重复，不同分区之间可以重复</li><li>分区副本机制<ul><li>replication-factor&#x3D;xxx，设置副本数量</li><li><img src="http://qiniu.c77544s.top/picgo/202305121146082.png" alt="image.png"></li></ul></li></ul></li><li>Record 消息记录<ul><li>Key—Value</li><li>不指定 key，key 为空，key 为空的消息会轮训写入不同分区</li><li>key 不为空时，相同的 key 会写入相同分区，保证了相同 key 的消息顺序写入</li></ul></li><li>Broker 消息代理<ul><li>Kafka 集群由多个 Broker 组成，通常一个服务器为一个Broker</li><li><img src="http://qiniu.c77544s.top/picgo/202305121152474.png" alt="image.png"></li></ul></li></ul><h2 id="Kafka-消息模型"><a href="#Kafka-消息模型" class="headerlink" title="Kafka 消息模型"></a>Kafka 消息模型</h2><ul><li>分区是最小的并行单位</li><li>一个消费者可消费多个分区</li><li>一个分区可被多个消费者组里的消费者消费</li><li>但是，一个分区不能同时被同一个消费者组里的多个消费者消费<br><img src="http://qiniu.c77544s.top/picgo/202305121220804.png" alt="image.png"></li></ul><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><ul><li>每个消费者都属于不同的消费者组<br><img src="http://qiniu.c77544s.top/picgo/202305121224553.png" alt="image.png"></li></ul><h3 id="点对点（一对一）"><a href="#点对点（一对一）" class="headerlink" title="点对点（一对一）"></a>点对点（一对一）</h3><ul><li>所有消费者都属于同一个消费者组</li><li>该模式也可以实现负载均衡，比如下图如果又加入了 <code>Consumer-4</code> 那么可将 <code>P3</code> 转交给 <code>Consumer-4</code> 处理<br><img src="http://qiniu.c77544s.top/picgo/202305121226271.png" alt="image.png"></li></ul><h3 id="分区与消息顺序"><a href="#分区与消息顺序" class="headerlink" title="分区与消息顺序"></a>分区与消息顺序</h3><ul><li><p>同一个生产者发送到同一分区的消息，先发送的 offset 比后发送的 offset 小</p></li><li><p>同一个生产者发送到不同分区的消息，消息顺序无法保证</p></li><li><p>消费者按照消息在分区里的存放顺序进行消费的</p></li><li><p>Kafka, 只保证分区内的消息顺序，不能保证分区间的消息顺序</p></li></ul><p><strong>如何保证消息全部有序？</strong></p><ol><li>设置一个分区，这样就可以保证所有消息的顺序，但是失去了拓展性和性能</li><li>通常是通过设置消息的 key, 相同 key 的消息会发送的同一个分区</li></ol><h3 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h3><p>需要生产者消费者共同来保证</p><h4 id="最多一次"><a href="#最多一次" class="headerlink" title="最多一次"></a>最多一次</h4><p>消息可能会丢失，永远不重复发送</p><h4 id="最少一次"><a href="#最少一次" class="headerlink" title="最少一次"></a>最少一次</h4><p>消息不会丢失，但是可能会重复</p><h4 id="精确一次"><a href="#精确一次" class="headerlink" title="精确一次"></a>精确一次</h4><p>保证消息被传递到服务端且在服务端不重复<br><strong>生产者实现精确一次</strong>需要实现幂等参数：<code>enable.idempotence=true  acts=all</code><br><strong>消费者实现精确一次</strong></p><ul><li>通过 offset 来防止重复消费不是一个好的办法</li><li>通常在消息中加入<strong>唯一 ID</strong> (例如流水 ID, 订单 ID)，在处理业务时，通过判断 ID 来防止重复处理</li></ul><h2 id="生产者-API"><a href="#生产者-API" class="headerlink" title="生产者 API"></a>生产者 API</h2><p>生产消息<br>同步与异步<br>消息确认<br>重试、批量、延迟<br>事务</p><h2 id="消费者-API"><a href="#消费者-API" class="headerlink" title="消费者 API"></a>消费者 API</h2><p>消费消息<br>自动提交与手动提交 offset<br>读取事务消息<br>Spring for Kafka</p><p>Kafka 中有一个主题 <code>__consumer_offsets</code> 用来保存消费者消费到哪个主题、哪个分区的哪个消费位置利于快速恢复</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p> 在 Kafka 中，生产者方即便事务执行中出现异常，异常前的消息也会被发送，只不过会有标记标识事务并未提交。<br> 在消费者方，可以设置 <code>isolation_level</code> 隔离级别，默认为 <code>read_uncommitted</code> 脏读，设置为 <code>read_committed</code> 只读取成功提交的数据，不会脏读</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>默认存储的二进制的形式<br><img src="http://qiniu.c77544s.top/picgo/202305121354022.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES中的倒排索引</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/ES%E4%B8%AD%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/ES%E4%B8%AD%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="http://qiniu.c77544s.top/picgo/202305112007982.png" alt="image.png"><br>Lucene 的倒排索，增加了最左边的一层「字典树」term index，它不存储所有的单词，只存储单词前缀，通过字典树找到单词所在的块，也就是单词的大概位置，再在块里二分查找，找到对应的单词，再找到单词对应的文档列表。</p><p>当然，内存寸土寸金，能省则省，所以 Lucene 还用了 FST（Finite State Transducers）对它进一步压缩。</p><p>FST 是什么？这里就不展开了，这次重点想聊的，是最右边的 Posting List 的，别看它只是存一个文档 ID 数组，但是它在设计时，遇到的问题可不少。</p><p>原生的 Posting List 有两个痛点：</p><ul><li><strong>如何压缩以节省磁盘空间</strong></li><li><strong>如何快速求交并集（intersections and unions）</strong></li></ul><h2 id="如何压缩节省磁盘空间"><a href="#如何压缩节省磁盘空间" class="headerlink" title="如何压缩节省磁盘空间"></a>如何压缩节省磁盘空间</h2><p><strong>Step 1：Delta-encode —— 增量编码</strong><br>我们只记录元素与元素之间的增量，于是数组变成了：<code>[73, 227, 2, 30, 11, 29]</code></p><p><strong>Step 2：Split into blocks —— 分割成块</strong><br>Lucene里每个块是 256 个文档 ID，这样可以保证每个块，增量编码后，每个元素都不会超过 256（1 byte）.<br>为了方便演示，我们假设每个块是 3 个文档 ID：<code>[73, 227, 2], [30, 11, 29]</code></p><p><strong>Step 3：Bit packing —— 按需分配空间</strong><br>对于第一个块，<code>[73, 227, 2]</code>，最大元素是227，需要 8 bits，好，那我给你这个块的每个元素，都分配 8 bits的空间。<br>但是对于第二个块，<code>[30, 11, 29]</code>，最大的元素才30，只需要 5 bits，那我就给你每个元素，只分配 5 bits 的空间，足矣。<br> <img src="http://qiniu.c77544s.top/picgo/202305112015943.png" alt="image.png"></p><h2 id="如何求交并集"><a href="#如何求交并集" class="headerlink" title="如何求交并集"></a>如何求交并集</h2><p><strong>Option 1: Bitmap</strong><br>假设有这样一个数组：<code>[3,6,7,10]</code><br>那么我们可以这样来表示：<code>[0,0,1,0,0,1,1,0,0,1]</code><br><strong>用 0 表示角标对应的数字不存在，用 1 表示存在。</strong></p><p>这样带来了两个好处：</p><ul><li>节省空间：既然我们只需要0和1，那每个文档 ID 就只需要 1 bit，还是假设有 100M 个文档，那只需要 100M bits &#x3D; 100M * 1&#x2F;8 bytes &#x3D; 12.5 MB，比之前用 Integer 数组 的 200 MB，优秀太多</li><li>运算更快：0 和 1，天然就适合进行位运算，求交集，「与」一下，求并集，「或」一下，一切都回归到计算机的起点</li></ul><p><strong>Option 2: Roaring Bitmaps</strong><br>bitmap 有个硬伤，就是不管有多少个文档，占用的空间都是一样的。<br>举一个极端的例子，有一个数组，里面只有两个文档 ID：<code>[0, 65535]</code><br>用 Bitmap，要怎么表示？<code>[1,0,0,0,…,(超级多个0),…,0,0,1]</code></p><p>可见在文档数量不多的时候，使用 Integer 数组更加节省内存。</p><p>我们来算一下临界值，很简单，无论文档数量多少，bitmap都需要 8192 bytes，而 Integer 数组则和文档数量成线性相关，每个文档 ID 占 2 bytes，所以：8192 &#x2F; 2 &#x3D; 4096</p><p>当文档数量少于 4096 时，用 Integer 数组，否则，用 bitmap.</p><blockquote><p>这里补充一下 Roaring bitmaps 和之前讲的 Frame Of Reference 的关系。  </p><p>Frame Of Reference 是压缩数据，减少磁盘占用空间，所以当我们从磁盘取数据时，也需要一个反向的过程，即解压，解压后才有我们上面看到的这样子的文档 ID 数组：<code>[73, 300, 302, 303, 343, 372]</code> ，接着我们需要对数据进行处理，求交集或者并集，这时候数据是需要放到内存进行处理的，我们有三个这样的数组，这些数组可能很大，而内存空间比磁盘还宝贵，于是需要更强有力的压缩算法，同时还要有利于快速的求交并集，于是有了 Roaring Bitmaps 算法。  </p><p>另外，Lucene 还会把从磁盘取出来的数据，通过 Roaring bitmaps 处理后，缓存到内存中，Lucene 称之为 filter cache. 这里补充一下 Roaring bitmaps 和之前讲的 Frame Of Reference 的关系。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL走了索引还是很慢？</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E5%BE%88%E6%85%A2%EF%BC%9F/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E5%BE%88%E6%85%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="查询速度影响因素"><a href="#查询速度影响因素" class="headerlink" title="查询速度影响因素"></a>查询速度影响因素</h2><p>MySQL 用到了索引和执行时间的长短没有必然关系，确定查询执行效率的是 “<strong>扫描行数</strong>”与“<strong>回表次数</strong>”。</p><ul><li>扫描行数</li><li>回表次数<br>在实际的 sql 优化过程中，也是尽量去优化这两块影响因素。</li></ul><h2 id="MySQL-选择-B-树索引结构的原因"><a href="#MySQL-选择-B-树索引结构的原因" class="headerlink" title="MySQL 选择 B+树索引结构的原因"></a>MySQL 选择 B+树索引结构的原因</h2><ol><li>内存占用：B+树可以把所有数据都放在叶子节点上，内部节点只存储索引信息，因此可以减少内存的占用。</li><li>顺序访问：B+树中的叶子节点之间通过链表相连，可以很方便地进行顺序访问和范围查询。</li><li>磁盘访问：对于磁盘上每个数据块大小固定的情况，B+树可以使一个节点大小等于一个数据块大小，这样可以最大化地利用磁盘容量。</li><li>多级索引：B+树支持多级索引，可以在数据量较大时不断分裂增加层数，提高查询效率。</li></ol><h2 id="聚集索引和非聚集索引（普通索引）"><a href="#聚集索引和非聚集索引（普通索引）" class="headerlink" title="聚集索引和非聚集索引（普通索引）"></a>聚集索引和非聚集索引（普通索引）</h2><ul><li>聚簇索引：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能有一个聚簇索引。<strong>叶子节点存储索引和行记录，聚簇索引查询会很快，因为可以直接定位到行记录</strong></li><li>非聚簇索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。<strong>叶子节点存储聚簇索引值（主键id），需要扫码两遍索引树，先通过普通索引定位到主键值id，再通过聚集索引定位到行记录</strong></li></ul><p>InnoDB 必须有一个主键索引，这里给 id 为主键，其次有 a、b 两个字段，再给 a 字段（姓名字段）一个普通索引，目前就有了主键索引和 a 索引树结构，如下图所示：<br><img src="http://qiniu.c77544s.top/picgo/202305111746033.png" alt="image.png"></p><blockquote><p>InnoDB 默认有主键索引，存储的是主键 id 1、2、3…，它是采用 B+ tree 的聚簇索引，所有的数据都存放在叶子结点中，而普通索引 a 采用非聚集索引，数据只包含对应的 id，没有整行数据，所以如果通过普通索引找到了某个 id，需要 select 别的字段，则还需要回表找主键索引中的整行数据取值！</p></blockquote><h2 id="几种调优方式"><a href="#几种调优方式" class="headerlink" title="几种调优方式"></a>几种调优方式</h2><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>索引覆盖，即将查询 sql 中的字段添加到联合索引里面，只要保证查询语句里面的字段都在索引文件中，就无需进行回表查询；</p><h3 id="索引下推（系统优化）"><a href="#索引下推（系统优化）" class="headerlink" title="索引下推（系统优化）"></a>索引下推（系统优化）</h3><p>在 MySQL5.6的版本中推出，用于优化查询。<strong>在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><h3 id="自查询（优化分页）"><a href="#自查询（优化分页）" class="headerlink" title="自查询（优化分页）"></a>自查询（优化分页）</h3><p>优化<strong>超多分页的场景</strong>。查询条件放到子查询中，子查询只查主键，然后使用子查询中确认的主键关联其他属性字段。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>比如要插入的很多连续的数据值都一样，则可以压缩成一条数据插入。</p><h3 id="硬件调优"><a href="#硬件调优" class="headerlink" title="硬件调优"></a>硬件调优</h3><p>增大 innodb buffer pool 多利用内存,减少硬盘回表</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>幂等是一个数学与计算机科学概念。</p><ul><li>在数学中，幂等用函数表达式就是：<code>f(x)=f(f(x))</code>。比如求绝对值的函数，就是幂等<br>的，<code>abs(x)=abs(abs(x))</code>。</li><li>计算机科学中，幂等表示一次和多次请求某一个资源应该具有同样的副作用，或者说，多<br>次请求所产生的影响与一次请求执行的影响效果相同。</li></ul><h2 id="如何设计幂等"><a href="#如何设计幂等" class="headerlink" title="如何设计幂等"></a>如何设计幂等</h2><p>幂等处理的过程，说到底其实就是过滤一下己经收到的请求，当然，请求一定要有一个<br><code>全局唯一的 D 标记 </code>。然后，怎么判断请求是否之前收到过呢？把请求储存起来，收到<br>请求时，先查下存储记录，记录存在就返回上次的结果，不存在就处理请求。<br><img src="http://qiniu.c77544s.top/picgo/202305111620137.png" alt="image.png"></p><h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="select（可省）-insert-主键-x2F-唯一索引冲突"><a href="#select（可省）-insert-主键-x2F-唯一索引冲突" class="headerlink" title="select（可省） + insert + 主键&#x2F;唯一索引冲突"></a>select（可省） + insert + 主键&#x2F;唯一索引冲突</h3><p>交易请求过来，我会先根据请求的<strong>唯一流水号</strong> <code>bizseq</code> 字段，先 <code>select</code> 一下数据库的流水表</p><ul><li>如果数据已经存在，就拦截是重复请求，直接返回成功：</li><li>如果数据不存在，就执行 <code>insert</code> 插入，如果 <code>insert</code> 成功，则直接返回成功，如果 <code>insert</code> 产生主键冲突异常，则捕获异常，接着直接返回成功。</li></ul><h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><p>很多业务表，都是有状态的，比如转账流水表，就会有 <code>0-待处理，1-处理中、2-成功、3-失败状态 </code>.转账流水更新的时候，都会涉及流水状态更新，即涉及状态机（即状态变更图）。</p><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><p>第一种是建立在业务流水表上 <code>bizseq</code> 的唯一性上。很多时候，我们业务表唯一流水号希望后端系统生成，又或者我们希望防重功能与业务表分隔开来，这时候我们可以单独搞个防重表。当然防重表也是利用主键&#x2F;索引的唯一性，如果插入防重表冲突即直接返回成功，如果插入成功，即去处理请求。</p><h3 id="token-令牌"><a href="#token-令牌" class="headerlink" title="token 令牌"></a>token 令牌</h3><ol><li>客户端请求申请获取 token, 服务端生成 token 返回</li><li>客户端带着 token 请求，服务端校验 token，token 存在则判断为第一次请求，token 不存在则为重复请求。</li></ol><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>比如 <code>select for update</code>，配合事务实现幂等，注意这种锁要使用主键查询<br><img src="http://qiniu.c77544s.top/picgo/202305111642701.png" alt="image.png"><br>一般不建议使用悲观锁实现幂等</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>就是给表的加多一列 <code>version</code> 版本号，每次更新记录 <code>version</code> 都升级一下 <code>(version=version+1)</code>。具体流程就是先查出当前的版本号 <code>version</code>,然后去更新修改数据时，确认下是不是刚刚查出的版本号，如果是才执行更新。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁实现幂等性的逻辑就是，请求过来时，先去尝试获得分布式锁，如果获得成功，就执行业务逻辑，反之获取失败的话，就舍弃请求直接返回成功。</p><ul><li>Redis 分布式锁，可以使用命令 <code>SET EX PX NX+唯一流水号</code> 实现，分布式锁的 <code>key</code> 必须为业务的唯一标识</li><li>Redis 执行设置 key 的动作时，要设置过期时间，这个过期时间不能太短，太短拦截不了重复请求，也不能设置太长，会占存储空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC原理</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/MVCC%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/MVCC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的四大特性—ACID"><a href="#事务的四大特性—ACID" class="headerlink" title="事务的四大特性—ACID"></a>事务的四大特性—ACID</h2><p>事务四个典型特性，即ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><ul><li>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。</li><li>一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li><li>隔离性： 多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。。</li><li>持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h2 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h2><p><strong>脏读</strong></p><blockquote><p>一个事务读取到了另一个未提交事务修改过的数据</p></blockquote><p><strong>不可重复读</strong></p><blockquote><p>同一个事务内，前后多次读取，读取到的数据内容不一致</p></blockquote><p><strong>幻读</strong></p><blockquote><p>一个事务根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录，第一个事务再查时发现数据不一致，与不可重复读的区别在于这里的是插入。</p></blockquote><h2 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交（RC）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读（RR）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>数据库隔离级别的 <strong>读已提交、可重复读</strong> 都是基于 MVCC 实现的</p><h2 id="MVCC-的关键知识点"><a href="#MVCC-的关键知识点" class="headerlink" title="MVCC 的关键知识点"></a>MVCC 的关键知识点</h2><h3 id="事务版本号"><a href="#事务版本号" class="headerlink" title="事务版本号"></a>事务版本号</h3><blockquote><p>事务每次开启前，都会从数据库获得一个<strong>自增</strong>长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p></blockquote><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>单调递增的行ID，不是必需的，占用6个字节。</td></tr><tr><td>trx_id</td><td>是</td><td>记录操作该数据事务的事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>这个隐藏列就相当于一个指针，指向回滚段的undo日志</td></tr></tbody></table><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><strong>回滚日志</strong>，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。</p><p>undo log有什么<strong>用途</strong>呢？</p><ol><li>事务回滚时，保证原子性和一致性。</li><li>用于MVCC<strong>快照读</strong></li></ol><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69abb7c89d1e4d9f8e242d9e0a410e3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="版本链"></p><h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p><strong>快照读：</strong> 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读。</p><p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> core_user <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>上在innodb中，每个SQL语句执行前都会得到一个Read View，用来做可见性判断的，即判断当前事务可见哪个版本的数据~</p><p>Read View是如何保证可见性判断的呢？我们先看看Read view 的几个重要属性</p><ul><li>m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。</li><li>min_limit_id:表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</li><li>max_limit_id:表示生成ReadView时，系统中应该分配给下一个事务的id值。</li><li>creator_trx_id: 创建当前read view的事务ID</li></ul><p><strong>Read view 匹配条件规则</strong>如下：</p><ol><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>,需腰分3种情况讨论</li></ol><blockquote><ul><li>（1）.如果<code>m_ids</code>包含<code>trx_id</code>,则代表Read View生成时刻，这个事务还未提交，但是如果数据的<code>trx_id</code>等于<code>creator_trx_id</code>的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</li><li>（2）如果<code>m_ids</code>包含<code>trx_id</code>，并且<code>trx_id</code>不等于<code>creator_trx_id</code>，则Read   View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</li><li>（3）.如果<code>m_ids</code>不包含<code>trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></blockquote><h2 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h2><ol><li>获取事务自己的版本号，即事务ID</li><li>获取Read View</li><li>查询得到的数据，然后Read View中的事务版本号进行比较。</li><li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li><li>最后返回符合规则的数据</li></ol><p>InnoDB 实现MVCC，是通过<code> Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。</p><h3 id="不同隔离级别下，Read-view的工作方式不同"><a href="#不同隔离级别下，Read-view的工作方式不同" class="headerlink" title="不同隔离级别下，Read view的工作方式不同"></a>不同隔离级别下，Read view的工作方式不同</h3><ul><li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li><li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li></ul><p>作者：捡田螺的小男孩<br>链接：<a href="https://juejin.cn/post/7016165148020703246">https://juejin.cn/post/7016165148020703246</a><br>来源：稀土掘金</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的跳表</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%A1%A8/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><code>Redis</code> 只在两个地方用到了跳跃表，一个是实现有序集合键（sorted set），另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在 <code>Redis</code> 里面没有其他用途。</p><p><img src="http://qiniu.c77544s.top/picgo/202305111157625.png" alt="image.png"></p><p>sorted set 同时使用压缩列表和跳表<br>在下列情况下使用压缩列表，否则使用跳表</p><ol><li>有序集合保存的元素数量小于 128 个</li><li>有序集合保存的所有元素的长度小于 64 字节</li></ol><p>为什么使用跳表而不使用红黑树或平衡树？</p><ol><li>zset 支持范围查找，跳表更好实现</li><li>跳表实现相对简单</li></ol><p><img src="http://qiniu.c77544s.top/picgo/202305111438516.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行流</title>
      <link href="/2023/05/10/%E5%90%8E%E7%AB%AF/Java/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
      <url>/2023/05/10/%E5%90%8E%E7%AB%AF/Java/%E5%B9%B6%E8%A1%8C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>并行流通过 <code>list.parallelStream()</code> 方法。当然也可以通过 <code>list.stream().parallel()</code> 将普通流转换成并行流。并行流也能通过 <code>sequential()</code> 方法转换为顺序流。但是：<strong>流的并行和顺序转换不会对流本身做任何实际的变化，仅仅是打了个标记而已。并且在一条流水线上对流进行多次并行 &#x2F; 顺序的转换，生效的是最后一次的方法调用</strong></p><blockquote><p>&#x3D;&#x3D;并行流内部使用了默认的 ForkJoinPool 线程池。<strong>默认的线程数量就是处理器的核心数</strong>&#x3D;&#x3D;，而配置系统核心属性：java.util.concurrent.ForkJoinPool.common.parallelism 可以改变线程池大小。不过该值是全局变量。改变他会影响所有并行流。目前还无法为每个流配置专属的线程数。一般来说采用处理器核心数是不错的选择</p></blockquote><h2 id="并行流并不可以随便用"><a href="#并行流并不可以随便用" class="headerlink" title="并行流并不可以随便用"></a>并行流并不可以随便用</h2><h3 id="可拆分性影响流的速度"><a href="#可拆分性影响流的速度" class="headerlink" title="可拆分性影响流的速度"></a>可拆分性影响流的速度</h3><ol><li>iterate 方法处理前 n 个数，比如 <code>Stream.iterate(1L, i -&gt; i + 1).limit(n).parallel()</code><ol><li>iterate 生成的是装箱的对象，必须拆箱成数字才能求和</li><li>对于 iterate 来说，每次应用这个函数都要依赖于前一次应用的结果。不仅不能有效的将流划分成小块处理。反而还因为并行化再次增加了开支。</li></ol></li><li>对于 <code>LongStream.rangeClosed()</code> 方法生成前 n 个数来说，就不存在 iterate 点问题，它生成的是基本类型的值，另外它可以直接将要生成的数字拆分成多个部分，并行状态下 <code>rangeClosed()</code> 是快于 for 循环外部迭代的。</li></ol><h3 id="共享变量修改的问题"><a href="#共享变量修改的问题" class="headerlink" title="共享变量修改的问题"></a>共享变量修改的问题</h3><p>因为是多线程，所以存在线程问题。</p><h3 id="并行流的使用注意"><a href="#并行流的使用注意" class="headerlink" title="并行流的使用注意"></a><strong>并行流的使用注意</strong></h3><ul><li>尽量使用 LongStream &#x2F; IntStream &#x2F; DoubleStream 等原始数据流代替 Stream 来处理数字，以避免频繁拆装箱带来的额外开销</li><li>要考虑流的操作流水线的总计算成本，假设 N 是要操作的任务总数，Q 是每次操作的时间。N * Q 就是操作的总时间，Q 值越大就意味着使用并行流带来收益的可能性越大。</li><li>对于较少的数据量，不建议使用并行流</li><li>容易拆分成块的流数据，建议使用并行流</li></ul><p>以下是一些常见的集合框架对应流的可拆分性能表<br><img src="http://qiniu.c77544s.top/picgo/202305101704679.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务产生的场景"><a href="#分布式事务产生的场景" class="headerlink" title="分布式事务产生的场景"></a>分布式事务产生的场景</h2><ul><li><strong>跨 JVM 进程产生分布式事务</strong><br><img src="http://qiniu.c77544s.top/picgo/202305101502764.png" alt="image.png"></li><li><strong>跨数据库实例产生分布式事务</strong><br><img src="http://qiniu.c77544s.top/picgo/202305101504958.png" alt="image.png"></li><li><strong>多服务访问同一个数据库实例</strong><br><img src="http://qiniu.c77544s.top/picgo/202305101504389.png" alt="image.png"></li></ul><h2 id="分布式事务的基础理论"><a href="#分布式事务的基础理论" class="headerlink" title="分布式事务的基础理论"></a>分布式事务的基础理论</h2><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>CAP 是 Consistency、Availability、Partition tolerance 三个单词的缩写，分别表示一致性、可用性、分区容忍性。</p><ol><li>C - Consistency    一致性</li><li>A - Availability   可用性</li><li>P - Partition tolerance    分区容忍性</li></ol><p><strong>CAP 的组合方式</strong></p><ol><li>AP<ol><li>放弃一致性，追求分区容忍性和可用性，只要保证最终一致性就行。这是很多分布式系统设计时的选择。因为大部分业务用户都能够接受在一段时间内获取不到最新的数据，最要最终能够获取到就可以。</li></ol></li><li>CP<ol><li>放弃可用性，追求一致性和分区容错性，zookeeper 其实就是追求的强一致，又比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</li></ol></li><li>CA<ol><li>放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统，最常用的关系型数据就满足了 CA。</li></ol></li></ol><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><blockquote><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。BASE 理论是对 CAP 中 AP 的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足 BASE 理论的事务，我们称之为“<strong>柔性事务</strong>”。  </p></blockquote><ol><li><strong>基本可用</strong>：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。</li><li><strong>软状态</strong>：由于不要求强一致性，所以 BASE 允许系统中存在中间状态（也叫<strong>软状态</strong>），这个状态不影响系统可用性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。</li><li><strong>最终一致</strong>：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ol><p>针对不同的分布式场景业界常见的解决方案有 <strong>2PC、3PC、TCC、可靠消息最终一致性、最大努力通知</strong>这几种</p><h2 id="2PC-解决方案"><a href="#2PC-解决方案" class="headerlink" title="2PC 解决方案"></a>2PC 解决方案</h2><h3 id="什么是-2PC"><a href="#什么是-2PC" class="headerlink" title="什么是 2PC"></a>什么是 2PC</h3><p>2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。</p><p>在计算机中部分关系数据库如 Oracle、MySQL 支持两阶段提交协议：</p><ol><li>准备阶段（Prepare phase）：事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo&#x2F;Redo 日志，此时事务没有提交。（Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件）</li><li>提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：<strong>必须在最后阶段释放锁资源</strong>。</li></ol><h3 id="XA-解决方案"><a href="#XA-解决方案" class="headerlink" title="XA 解决方案"></a>XA 解决方案</h3><p>2PC 的传统方案是在数据库层面实现的，如 Oracle、MySQL 都支持 2PC 协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织 Open Group 定义了分布式事务处理模型<strong>DTP</strong>（Distributed Transaction Processing Reference Model）。<br>下面以新用户注册送积分为例来说明 XA 方案：<br><img src="http://qiniu.c77544s.top/picgo/202305111040213.png" alt="image.png"><br>执行流程如下：</p><ol><li>应用程序（AP）持有用户库和积分库两个数据源。</li><li>应用程序（AP）通过 TM 通知用户库 RM 新增用户，同时通知积分库RM为该用户新增积分，RM 此时并未提交事务，此时用户和积分资源锁定。</li><li>TM 收到执行回复，只要有一方失败则分别向其他 RM 发起回滚事务，回滚完毕，资源锁释放。</li><li>TM 收到执行回复，全部成功，此时向所有 RM 发起提交事务，提交完毕，资源锁释放。</li></ol><p>DTP 模型定义如下角色：</p><ul><li><strong>AP</strong>（Application Program）：即应用程序，可以理解为使用 DTP 分布式事务的程序。</li><li><strong>RM</strong>（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。</li><li><strong>TM</strong>（Transaction Manager）：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个 RM。<strong>全局事务</strong>是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。</li><li>DTP 模型定义 TM 和 RM 之间通讯的接口规范叫 <strong>XA</strong>，简单理解为数据库提供的 2PC 接口协议，<strong>基于数据库的 XA 协议来实现 2PC 又称为 XA 方案</strong></li></ul><p><strong>XA 方案的问题</strong></p><ol><li>需要本地数据库支持XA协议。</li><li>资源锁需要等到两个阶段结束才释放，性能较差</li></ol><h3 id="Seata-方案"><a href="#Seata-方案" class="headerlink" title="Seata 方案"></a>Seata 方案</h3><p>Seata 是由阿里中间件团队开源的分布式事务框架。</p><p>Seata 通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是<strong>工作在应用层</strong>的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务 0 侵入的方式解决微服务场景下面临的分布式事务问题，它目前提供 AT 模式（即 2PC）及 TCC 模式的分布式事务解决方案。</p><p>Seata 把一个分布式事务理解成一个包含了若干<strong>分支事务</strong>的<strong>全局事务</strong>。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务。</p><ul><li>Transaction Coordinator（TC）：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收 TM 指令发起全局事务的提交与回滚，负责与 RM 通信协调各各分支事务的提交或回滚。</li><li>Transaction Manager（TM）： 事务管理器，TM 需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向 TC 发起全局提交或全局回滚的指令。</li><li>Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚。<br><img src="http://qiniu.c77544s.top/picgo/202305111045883.png" alt="image.png"><br>具体的执行流程如下：</li></ul><ol><li>用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。  </li><li>用户服务的 RM 向 TC 注册分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖。</li><li>用户服务执行分支事务，向用户表插入一条记录。  </li><li>逻辑执行到远程调用积分服务时（XID 在微服务调用链路的上下文中传播）。积分服务的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。  </li><li>积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。  </li><li>用户服务分支事务执行完毕。  </li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。  </li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li><li><strong>Seata 实现2PC 与传统2PC 的差别</strong><br><strong>架构层次方面</strong>：传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的。<br><strong>两阶段提交方面</strong>：传统 2PC 无论第二阶段的决议是 commit 还是 rollback ，事务性资源的锁都要保持到 Phase2 完成才释放。而 Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效率。</li></ol><h2 id="TCC-解决方案"><a href="#TCC-解决方案" class="headerlink" title="TCC 解决方案"></a>TCC 解决方案</h2><p>TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm&#x2F;Cancel 操作若执行失败，TM 会进行重试。</p><p>TCC 分为三个阶段：</p><ol><li><strong>Try</strong> 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑。</li><li><strong>Confirm</strong> 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。</li><li><strong>Cancel</strong> 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。</li></ol><h3 id="TCC-异常处理"><a href="#TCC-异常处理" class="headerlink" title="TCC 异常处理"></a>TCC 异常处理</h3><p>TCC 需要注意三种异常处理分别是<strong>空回滚</strong>、<strong>幂等</strong>、<strong>悬挂</strong></p><p>TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条，可通过额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID。比如，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。</p><ol><li><strong>空回滚</strong><br>在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚（分支事务记录表中没 try 数据），然后直接返回成功。</li><li>幂等<br> TCC 二阶段提交重试机制可能会造成数据不一致，要求 TCC 的二阶段 Try、Conﬁrm 和 Cancel 接口保证幂等</li><li>悬挂<br>悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。<br>出现原因是在 RPC 调用分支事务 Try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行。而该分布式事务第一阶段预留的业务资源就再也没有人能够处理了<br>解决思路是：”分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行 Try。</li></ol><p>如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让<strong>应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能</strong>。</p><h2 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h2><p>可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方（消息消费者）一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。<br><img src="http://qiniu.c77544s.top/picgo/202305111110457.png" alt="image.png"><br>可靠消息最终一致性方案要解决以下几个问题：</p><ol><li><strong>本地事务与消息发送的原子性问题</strong><br>本地事务与消息发送的原子性问题即：要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。<br>下面这种操作，先发送消息，在操作数据库：<br><code>mysql begin transaction； //1.发送MQ //2.数据库操作 commit transation;</code><br>这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。 那么第二种方案，先进行数据库操作，再发送消息：<br><code>mysql begin transaction； //1.数据库操作 //2.发送MQ commit transation;</code><br>这种情况下貌似没有问题，如果发送 MQ 消息失败，就会抛出异常，导致数据库事务回滚。但如果是超时异常，数据库回滚，但 MQ 其实已经正常发送了，同样会导致不一致。  </li><li><strong>事务参与方接收消息的可靠性</strong><br>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。  </li><li><strong>消息重复消费的问题</strong><br>由于网络2的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。<br>要解决消息重复消费的问题就要实现事务参与方的方法幂等性。</li></ol><h3 id="解决方案：本地消息表方案"><a href="#解决方案：本地消息表方案" class="headerlink" title="解决方案：本地消息表方案"></a>解决方案：本地消息表方案</h3><p>此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。<br><img src="http://qiniu.c77544s.top/picgo/202305111114290.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性：</p><ol><li>本地事务与消息发送的原子性问题。</li><li>事务参与方接收消息的可靠性。</li></ol><p>可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p><h2 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h2><p><img src="http://qiniu.c77544s.top/picgo/202305111137304.png" alt="image.png"><br>交互流程：</p><ol><li>账户系统调用充值系统接口</li><li>充值系统完成支付处理向账户发起充值结果通知，若通知失败，则充值系统按策略进行重复通知</li><li>账户系统接收到充值结果通知修改充值状态</li><li>账户系统未接收到通知会主动调用充值系统的接口查询充值结果</li></ol><p>通过上边的例子我们总结最大努力通知方案的目标：<strong>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方</strong>。</p><ol><li>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知</li><li>消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>方案 1 :<br><img src="http://qiniu.c77544s.top/picgo/202305111139581.png" alt="image.png"><br>本方案是利用 MQ 的 ack 机制由 MQ 向接收通知方发送通知<br>方案 2 ：<br><img src="http://qiniu.c77544s.top/picgo/202305111140811.png" alt="image.png"><br><strong>方案1和方案2的不同点</strong>：</p><ol><li>方案 1 中接收通知方与 MQ 接口，即接收通知方案监听 MQ，此方案主要应用与内部应用之间的通知。</li><li>方案 2 中由通知程序与 MQ 接口，通知程序监听 MQ，收到 MQ 的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>分布式事务对比分析</strong></p><p><strong>2PC</strong> 最大的诟病是一个阻塞协议。RM 在执行分支事务后需要等待 TM 的决定，此时服务会阻塞并锁定资源。由于其阻塞机制和最差时间复杂度高，因此，这种设计不能适应随着事务涉及的服务数量增加而扩展的需要，很难用于并发较高以及子事务生命周期较长（long-running transactions） 的分布式服务中。</p><p>如果拿<strong>TCC</strong>事务的处理流程与2PC两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让<strong>应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能</strong>。而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 Try、Conﬁrm、Cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实 现不同的回滚策略。典型的使用场景：满减，登录送优惠券等。</p><p><strong>可靠消息最终一致性</strong>事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。典型的使用场景：注册送积分，登录送优惠券等。</p><p><strong>最大努力通知</strong>是分布式事务中要求最低的一种,适用于一些最终一致性时间敏感度低的业务；允许发起通知方处理业务失败，在接收通知方收到通知后积极进行失败处理，无论发起通知方如何处理结果都会不影响到接收通知方的后续处理；发起通知方需提供查询执行情况接口，用于接收通知方校对结果。典型的使用场景：银行通知、支付结果通知等。<br><img src="http://qiniu.c77544s.top/picgo/202305111141517.png" alt="image.png"></p><p>无论是数据库层的 XA、还是应用层 TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。</p><p><a href="https://zhuanlan.zhihu.com/p/263555694">分布式事务有这一篇就够了！ - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁的实现</title>
      <link href="/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基于-Redis-实现"><a href="#基于-Redis-实现" class="headerlink" title="基于 Redis 实现"></a>基于 Redis 实现</h2><p>相关概念：</p><ul><li>setnx</li><li>lua</li><li>redisson</li><li>redlock</li></ul><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h3><p>目前通常所说的 setnx ( <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists ) 命令，并非单指 redis 的 setnx key value 这条命令（因为未来 redis 可能要废除 setnx 命令）。<br>一般代指redis中对<strong>set</strong>命令加上<strong>nx</strong>参数进行使用， <strong>set</strong>这个命令，目前已经支持这么多参数可选：<br><code>SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</code><br>其中 <code>EX</code> 和 <code>PX</code> 参数设置过期时间<br><code>NX</code> ：只在键不存在时，才对键进行设置操作。执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code><br><code>XX</code>：只在键已经存在时，才对键进行设置操作。</p><blockquote><p>在设置分布式锁时，要保证 value 值唯一，通常是<strong>UUID + threadId</strong>，在删除缩时判断 value 是否是当前线程加的锁</p></blockquote><p>setnx 的方式虽然在加锁的时候可以保证原子性，但是在解锁时要先获取 value 再删除，无法保证原子性，可以用 lua 脚本实现原子性的解锁操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua删除锁：</span></span><br><span class="line"><span class="comment">-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。</span></span><br><span class="line"><span class="comment">-- 如果对应的value等于传入的uuid。</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line"><span class="comment">-- 执行删除操作</span></span><br><span class="line">        <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"><span class="comment">-- 不成功，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用 setnx 还存在锁续期等问题</p><h3 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h3><p>redisson 中<strong>加锁&#x2F;释放锁</strong>操作都是用<strong>lua</strong>脚本完成的，封装的非常完善，开箱即用。<br>此外，redisson 中通过 <code>watch dog</code> 机制实现了锁续期的功能，锁的可靠性上更加完善。<br>同时，redisson 实现的锁是可重入的。</p><h4 id="Watch-dog"><a href="#Watch-dog" class="headerlink" title="Watch dog"></a>Watch dog</h4><p><img src="http://qiniu.c77544s.top/picgo/202210121456281.png" alt="img"><br>redisson 在获取锁的时候，默认的 ttl 是30秒，Watch dog 会每隔10秒看一下，如果还持有锁，将 ttl 续期30s（可以通过修改 Config.lockWatchdogTimeout 来另行指定），从而实现分布式锁的续期。</p><ol><li>watch dog 在当前节点存活时每10s给分布式锁的key续期 30s；</li><li>watch dog 机制启动，且代码中没有释放锁操作时，watch dog 会不断的给锁续期；</li><li>从可2得出，如果程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；</li></ol><p>&#x3D;&#x3D;redisson 方案存在的问题：**&#x3D;&#x3D;</p><ol><li><strong>长时间的 GC pause：</strong> 如果 watch dog 所在服务在续期之前，JVM 进行的 <code>STW</code>，而 <code>STW</code> 的时间又很长，长到超过了锁的过期时间，这样就会出现程序还没有释放锁，但是又会被其他线程锁上。</li><li><strong>时钟发生跳跃：</strong> 对于 Redis 服务器如果其时间发生了向跳跃，那么肯定会影响我们锁的过期时间，那么我们的锁过期时间就不是我们预期的了，也会出现 client1和 client2获取到同一把锁，那么也会出现不安全，这个对于 Mysql 也会出现。但是 ZK 由于没有设置过期时间，那么发生跳跃也不会受影响。</li><li><strong>长时间的网络 I&#x2F;O</strong>：这个问题和我们的 GC 的 STW 很像，也就是我们这个获取了锁之后我们进行网络调用，其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题，这个 Mysql 也会有，ZK 也不会出现这个问题。</li></ol><h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>首先 RedLock 的实现需要有 N 个 Redis Master。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>（RedLock 依赖的环境不能是一个由 N 主 N 从组成的 Cluster 集群模式，因为 Cluster 模式下的各个 Master 并不完全独立，而是存在 Gossip 协调机制的）。之所以要用独立的，是避免了 redis 异步复制造成的锁丢失，比如：主节点没来的及把<strong>刚刚 set 进来这条数据</strong>给从节点，就挂了。<br><img src="http://qiniu.c77544s.top/picgo/202305101419734.png" alt="image.png"></p><p>红锁算法认为，只要2N + 1个节点加锁成功，那么就认为获取了锁，解锁时将所有实例解锁。流程为：</p><ol><li>顺序向五个节点请求加锁</li><li>根据一定的<strong>超时时间</strong>来推断是不是跳过该节点</li><li>三个节点加锁成功并且花费时间小于锁的有效期</li><li>认定加锁成功</li></ol><blockquote><p>Redisson 中已经封装好了 RedLock 的开源实现。</p></blockquote><p>RedLock 方案相比普通的 Redis 分布式锁方案<strong>可靠性</strong>确实大大提升，但一般业务中只需要一个 Redis Cluster，或者一个 Sentinel，但是这两者都不能承载 RedLock 的落地。</p><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>基本原理和 Redis 的 SETNX 类似，其实就是创建一个分布式锁表，加锁后，在表增加一条记录，释放锁即把该数据删掉。<br><img src="http://qiniu.c77544s.top/picgo/202305101439972.png" alt="image.png"></p><p><strong>它同样存在一些问题：</strong></p><ol><li>没有失效时间，容易导致死锁；</li><li>依赖数据库的可用性，一旦数据库挂掉，锁就马上不可用；</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作；</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库中数据已经存在了。</li></ol><ul><li>优点:理解起来简单，不需要维护额外的第三方中间件(比如 Redis,Zk)。</li><li>缺点:虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。</li></ul><h2 id="基于-Zookeeper-的分布式锁"><a href="#基于-Zookeeper-的分布式锁" class="headerlink" title="基于 Zookeeper 的分布式锁"></a>基于 Zookeeper 的分布式锁</h2><p>实现原理为：</p><ol><li>建立一个节点，假如名为 lock 。节点类型为持久节点（Persistent）</li><li>每当进程需要访问共享资源时，会调用分布式锁的 lock() 或 tryLock() 方法获得锁，这个时候会在第一步创建的 lock 节点下建立相应的顺序子节点，节点类型为临时顺序节点（<code>EPHEMERAL_SEQUENTIAL</code>），通过组成特定的名字 name+lock+顺序号。</li><li>在建立子节点后，对 lock 下面的所有以 name 开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。</li><li>假如不是该节点，就获得该节点的上一顺序节点，并监测该节点是否存在注册监听事件。同时在这里阻塞，等待监听事件的发生（watcher），获得锁控制权。(这里的watcher其实调用的是object.notifyAll(),用来解除阻塞)。</li><li>当调用完共享资源后，调用 unlock() 方法，关闭 ZooKeeper，进而可以引发监听事件，释放该锁。</li></ol><p><img src="http://qiniu.c77544s.top/picgo/202305101443186.png" alt="image.png"></p><ul><li>优点: ZK 可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，ZK 获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用 ZK 集群进行保证。</li><li>缺点:ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 如何提高接口数据安全性</title>
      <link href="/2023/05/08/%E5%90%8E%E7%AB%AF/Spring%20Boot/Spring%20Boot%20%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2023/05/08/%E5%90%8E%E7%AB%AF/Spring%20Boot/Spring%20Boot%20%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在 Spring Boot 项目中提高接口安全的核心所在：<strong>加密和加签</strong>，加固接口参数、验证复杂度。</p><p><strong>加密：</strong> 对参数进行加密传输，拒绝接口参数直接暴露，这样就可以有效做到防止别人轻易准确地获取到接口参数定义和传参格式要求了。</p><p><strong>加签：</strong> 对接口参数进行加签，可以有效防止接口参数被篡改和接口参数被重放恶刷。</p><h2 id="1-加密"><a href="#1-加密" class="headerlink" title="1. 加密"></a>1. 加密</h2><p>采用<strong>非对称加密算法 RSA 和对称加密算法 AES</strong>来完成接口加密</p><blockquote><p><strong>AES 是对称加密算法</strong>，优点：加密速度快；缺点：如果秘钥丢失，就容易解密密文，安全性相对比较差<br><strong>RSA 是非对称加密算法</strong> ，优点：安全；缺点：加密速度慢</p></blockquote><p>接口参数加解密的流程大致如图所示：<br><img src="http://qiniu.c77544s.top/picgo/202305091014736.png" alt="接口参数加解密流程.png"></p><h2 id="2-验签"><a href="#2-验签" class="headerlink" title="2. 验签"></a>2. 验签</h2><p>签名验证也是当下提高接口安全性主要措施之一，核心就是客户端在调用接口时按照一定规则生成签名 <code>sign</code>，服务端拿到签名 <code>sign</code> 之后进行验证操作，大致流程如下：<br><img src="http://qiniu.c77544s.top/picgo/202305091016734.png" alt="image.png"></p><h2 id="3-优雅实现接口加密、加签"><a href="#3-优雅实现接口加密、加签" class="headerlink" title="3. 优雅实现接口加密、加签"></a>3. 优雅实现接口加密、加签</h2><p>对加密、加签操作进行了公共的抽取封装，同时通过一个注解 <code>@ApiSecurity</code> 来标识接口是否需要进行加密、加签操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiSecurity &#123;​</span><br><span class="line">    <span class="meta">@Alias(&quot;isSign&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加签验证，默认开启</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Alias(&quot;value&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSign</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口请求参数是否需要解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">decryptRequest</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口响应参数是否需要加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">encryptResponse</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注解属性可以看到签名验证默认是开启的，因为我们认为接口安全性加签是必须的，至于参数加解密可以视情况而定。<br>使用案例：下面就是一个需要加密加签的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/security&quot;)</span></span><br><span class="line"><span class="meta">@ApiSecurity(encryptResponse = true, decryptRequest = true)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">testApiSecurity</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对接口加密、加签功能实现统一和规范，这里将实现抽取，封装集成在自定义的 <code>web starter</code> 中，这样只要项目服务引入这个 starter 依赖就可以使用该功能了</p><p>首先对加密传输的参数 bean 进行规定封装如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiSecurityParam</span> &#123;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA加密后的aes秘钥，需解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES加密的json参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String data;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sign;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String timestamp;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nonce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等于说加密、加签的参数格式，调用方需按照上面的对象传参，当然为了提高拓展性，签名的相关信息 <code>sign、timestamp、nonce</code> 可以放到请求的 <code>header</code> 里面，也能获取到。拿到 <code>apiSecurityParam</code> 我们就可以进行请求参数解密、验签了，需要通过判断是否使用了注解 <code>@ApiSecuriy</code> 来决定是否执行请求参数解密、验签逻辑，这就正好可以使用基于注解的切面实现啦，在说切面之前，先说说一次接口请求 <code>requestBody</code> 的输入流 InputStream 只能读取一次，就是说 <code>request.getInputStream()</code> 只能使用一次，原因如下：</p><p><strong>因为流对应的是数据，数据放在内存中，有的是部分放在内存中。read 一次标记一次当前位置（mark position），第二次read就从标记位置继续读（从内存中copy）数据。 所以这就是为什么读了一次第二次是空了。 怎么让它不为空呢？只要inputstream 中的pos 变成0就可以重写读取当前内存中的数据。javaAPI中有一个方法public void reset() 这个方法就是可以重置pos为起始位置，但是不是所有的IO读取流都可以调用该方法！ServletInputStream是不能调用reset方法，这就导致了只能调用一次getInputStream()。</strong></p><p>而我们需要先读取出<code>requestBody</code>进行解密，然后拿到解密之前的参数映射到真正的接口方法参数对象里，所以必须解决这个问题。</p><p>解决方法就是原始的<code>HttpServletRequest</code>的InputStream只能读取一下，那么我们就重新自定义封装一个<code>HttpServletRequest</code>可以实现多次读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestBodyWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//用于将流保存下来</span></span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RequestBodyWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">        body = <span class="keyword">new</span> <span class="title class_">String</span>(StreamUtils.copyToByteArray(request.getInputStream()), StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写getInputStream， 从body中获取请求参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">ServletInputStream</span> <span class="variable">servletInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener readListener)</span> &#123;</span><br><span class="line">​</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> servletInputStream;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String body)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>接下来就可以来看看切面了：这里是解析请求参数和验签和逻辑所在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Order(value = OrderConstant.AOP_API_DECRYPT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiSecurityAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApiSecurityProperties apiSecurityProperties;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NONCE_KEY</span> <span class="operator">=</span> <span class="string">&quot;x-nonce-&quot;</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.plasticene..controller..*(..)) &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;(@annotation(com.plasticene.boot.web.core.anno.ApiSecurity) ||&quot; +</span></span><br><span class="line"><span class="meta">            &quot; @target(com.plasticene.boot.web.core.anno.ApiSecurity))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">securityPointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Around(&quot;securityPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundApiSecurity</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//=======AOP解密切面通知=======</span></span><br><span class="line">        <span class="type">ApiSecurity</span> <span class="variable">apiSecurity</span> <span class="operator">=</span> getApiSecurity(joinPoint);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSign</span> <span class="operator">=</span> apiSecurity.isSign();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">decryptRequest</span> <span class="operator">=</span> apiSecurity.decryptRequest();</span><br><span class="line">        <span class="comment">// 获取request加密传递的参数</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> getRequest();</span><br><span class="line">        <span class="comment">// 只能针对post接口的请求参数requestBody进行统一加解密和加签，这是规定</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(<span class="string">&quot;POST&quot;</span>, request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;只能POST接口才能加密加签操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取controller接口方法定义的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object[] newArgs = args;</span><br><span class="line">        <span class="type">ApiSecurityParam</span> <span class="variable">apiSecurityParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiSecurityParam</span>();</span><br><span class="line">        <span class="comment">// 请求参数解密</span></span><br><span class="line">        <span class="keyword">if</span> (decryptRequest) &#123;</span><br><span class="line">            <span class="comment">// 不支持多个请求，因为解密请求参数之后会json字符串，再根据请求参数的类型映射过去，如果有多个参数就不知道映射关系了</span></span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;加密接口方法只支持一个参数，请修改&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// args.length=0没有请求参数，就说明没必要解密，因为接口压根不接收参数，即使使用者无脑开启的该接口的参数加密，这里不做任何逻辑即可</span></span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">                RequestBodyWrapper requestBodyWrapper;</span><br><span class="line">                <span class="keyword">if</span> (request <span class="keyword">instanceof</span> RequestBodyWrapper) &#123;</span><br><span class="line">                    requestBodyWrapper = (RequestBodyWrapper) request;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    requestBodyWrapper = <span class="keyword">new</span> <span class="title class_">RequestBodyWrapper</span>(request);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> requestBodyWrapper.getBody();</span><br><span class="line">                apiSecurityParam = JSONObject.parseObject(body, ApiSecurityParam.class);</span><br><span class="line">                <span class="comment">// 通过RSA私钥解密获取到aes秘钥</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">aesKey</span> <span class="operator">=</span> RSAUtil.decryptByPrivateKey(apiSecurityParam.getKey(), apiSecurityProperties.getRsaPrivateKey());</span><br><span class="line">                <span class="comment">// 通过aes秘钥解密data参数数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> AESUtil.decrypt(apiSecurityParam.getData(), aesKey);</span><br><span class="line">                <span class="comment">//获取接口入参的类</span></span><br><span class="line">                Class&lt;?&gt; c = args[<span class="number">0</span>].getClass();</span><br><span class="line">                <span class="comment">//将获取解密后的真实参数，封装到接口入参的类中</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> JSONObject.parseObject(data, c);</span><br><span class="line">                newArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;o&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验签</span></span><br><span class="line">        <span class="keyword">if</span> (isSign) &#123;</span><br><span class="line">            verifySign(request, newArgs.length == <span class="number">0</span> ? <span class="literal">null</span> : newArgs[<span class="number">0</span>], apiSecurityParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed(newArgs);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">verifySign</span><span class="params">(HttpServletRequest request, Object o, ApiSecurityParam apiSecurityParam)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果请求参数是加密传输的，那就先从ApiSecurityParam获取签名和时间戳等等。</span></span><br><span class="line">        <span class="comment">// 如果请求参数不是加密传输的，那么ApiSecurityParam的字段取值都为null，这时候在请求的header里面获取参数信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> apiSecurityParam.getSign();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sign)) &#123;</span><br><span class="line">            sign = request.getHeader(<span class="string">&quot;X-Sign&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sign)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;签名不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> apiSecurityParam.getNonce();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(nonce)) &#123;</span><br><span class="line">            nonce = request.getHeader(<span class="string">&quot;X-Nonce&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(nonce)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;唯一标识不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> apiSecurityParam.getTimestamp();</span><br><span class="line">        Long t;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(timestamp)) &#123;</span><br><span class="line">            timestamp = request.getHeader(<span class="string">&quot;X-Timestamp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(timestamp)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;时间戳不能为空&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t = Long.valueOf(timestamp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;非法的时间戳&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断timestamp时间戳与当前时间是否超过签名有效时长（过期时间根据业务情况进行配置）,如果超过了就提示签名过期</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - t &gt; apiSecurityProperties.getValidTime()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;签名已过期&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断nonce</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">nonceExists</span> <span class="operator">=</span> stringRedisTemplate.hasKey(NONCE_KEY + nonce);</span><br><span class="line">        <span class="keyword">if</span> (nonceExists) &#123;</span><br><span class="line">            <span class="comment">//请求重复</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;唯一标识nonce已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 验签</span></span><br><span class="line">        <span class="type">SortedMap</span> <span class="variable">sortedMap</span> <span class="operator">=</span> SignUtil.beanToMap(o);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> SignUtil.getContent(sortedMap, nonce, timestamp);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> RSAUtil.verifySignByPublicKey(content, sign, apiSecurityProperties.getRsaPublicKey());</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;签名验证不通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        stringRedisTemplate.opsForValue().set(NONCE_KEY+ nonce, <span class="string">&quot;1&quot;</span>, apiSecurityProperties.getValidTime(),</span><br><span class="line">                TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> ApiSecurity <span class="title function_">getApiSecurity</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line">        <span class="type">ApiSecurity</span> <span class="variable">apiSecurity</span> <span class="operator">=</span> method.getAnnotation(ApiSecurity.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(apiSecurity)) &#123;</span><br><span class="line">            apiSecurity = method.getDeclaringClass().getAnnotation(ApiSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apiSecurity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码没什么好讲的了，就按照上面的加密、加签流程图逻辑实现的，而且注释也很清楚，可以自己慢慢消化，这里面涉及的工具类如 <code>RSAUtil、AESUtil、SignUtil</code> 等，碍于文章代码篇幅，我就这里就在一一展示，我会在文章后面放上全部代码的项目 github 地址以供下载的。</p><p>上面的切面只完成了接口参数的解密和验签，至于对响应参数的加密返回放到了<code>ResponseBodyAdvice</code>中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseResultBodyAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApiSecurityProperties apiSecurityProperties;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类或者方法是否使用了 <span class="doctag">@ResponseResultBody</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseResultBody.class)</span><br><span class="line">                || returnType.hasMethodAnnotation(ResponseResultBody.class)</span><br><span class="line">                || AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ApiSecurity.class)</span><br><span class="line">                || returnType.hasMethodAnnotation(ApiSecurity.class);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当类或者方法使用了 <span class="doctag">@ResponseResultBody</span> 就会调用这个方法</span></span><br><span class="line"><span class="comment">     * 如果返回类型是string，那么springmvc是直接返回的，此时需要手动转化为json</span></span><br><span class="line"><span class="comment">     * 因为当body都为null时，下面的非加密下的if判断参数类型的条件都不满足，如果接口返回类似为String，</span></span><br><span class="line"><span class="comment">     * 会报错com.shepherd.fast.global.ResponseVO cannot be cast to java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> returnType.getMethod();</span><br><span class="line">        Class&lt;?&gt; returnClass = method.getReturnType();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">enable</span> <span class="operator">=</span> apiSecurityProperties.getEnable();</span><br><span class="line">        <span class="type">ApiSecurity</span> <span class="variable">apiSecurity</span> <span class="operator">=</span> method.getAnnotation(ApiSecurity.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(apiSecurity)) &#123;</span><br><span class="line">            apiSecurity = method.getDeclaringClass().getAnnotation(ApiSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (enable &amp;&amp; Objects.nonNull(apiSecurity) &amp;&amp; apiSecurity.encryptResponse() &amp;&amp; Objects.nonNull(body)) &#123;</span><br><span class="line">            <span class="comment">// 只需要加密返回data数据内容</span></span><br><span class="line">            <span class="keyword">if</span> (body <span class="keyword">instanceof</span> ResponseVO) &#123;</span><br><span class="line">                body = ((ResponseVO) body).getData();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> encryptResponse(body);</span><br><span class="line">            body = jsonObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (body <span class="keyword">instanceof</span> String || Objects.equals(returnClass, String.class)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> objectMapper.writeValueAsString(ResponseVO.success(body));</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 防止重复包裹的问题出现</span></span><br><span class="line">            <span class="keyword">if</span> (body <span class="keyword">instanceof</span> ResponseVO) &#123;</span><br><span class="line">                <span class="keyword">return</span> body;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseVO.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    JSONObject <span class="title function_">encryptResponse</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">aseKey</span> <span class="operator">=</span> AESUtil.generateAESKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> JSONObject.toJSONString(result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> AESUtil.encrypt(content, aseKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RSAUtil.encryptByPublicKey(aseKey, apiSecurityProperties.getRsaPublicKey());</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：shepherd111<br>链接：<a href="https://juejin.cn/post/7230656455806976058">https://juejin.cn/post/7230656455806976058</a><br>来源：稀土掘金<br><strong>Github 地址</strong>：<a href="https://github.com/plasticene/plasticene-boot-starter-parent">plasticene-boot-starter-parent(github.com)</a><br><strong>Gitee地址</strong>：<a href="https://gitee.com/plasticene3/plasticene-boot-starter-parent">plasticene-boot-starter-parent(gitee.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB整合到Spring Boot</title>
      <link href="/2023/05/08/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB%E6%95%B4%E5%90%88%E5%88%B0Spring%20Boot/"/>
      <url>/2023/05/08/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB%E6%95%B4%E5%90%88%E5%88%B0Spring%20Boot/</url>
      
        <content type="html"><![CDATA[<h3 id="1-本机测试，使用-Docker-快速搭建-MongoDB："><a href="#1-本机测试，使用-Docker-快速搭建-MongoDB：" class="headerlink" title="1. 本机测试，使用 Docker 快速搭建 MongoDB："></a>1. 本机测试，使用 Docker 快速搭建 MongoDB：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -itd --name mongo -p 27017:27017 mongo --auth</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it mongo mongo admin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 admin，密码为 123456 的用户。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"> db.createUser(&#123; user:<span class="string">&#x27;admin&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;123456&#x27;</span>,roles:[ &#123; role:<span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="string">&#x27;admin&#x27;</span>&#125;,<span class="string">&quot;readWriteAnyDatabase&quot;</span>]&#125;);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试使用上面创建的用户信息进行连接，验证成功返回1。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.auth(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="2-Spring-Boot-导入-mongodb-相关依赖"><a href="#2-Spring-Boot-导入-mongodb-相关依赖" class="headerlink" title="2. Spring Boot 导入 mongodb 相关依赖"></a>2. Spring Boot 导入 mongodb 相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编辑-Spring-Boot-配置文件"><a href="#3-编辑-Spring-Boot-配置文件" class="headerlink" title="3. 编辑 Spring Boot 配置文件"></a>3. 编辑 Spring Boot 配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line"><span class="attr">mongodb:</span>  </span><br><span class="line"><span class="attr">uri:</span> <span class="string">mongodb://admin:123456@localhost:27017/admin</span></span><br></pre></td></tr></table></figure><h3 id="4-基于MongoTemplate-开发CRUD"><a href="#4-基于MongoTemplate-开发CRUD" class="headerlink" title="4. 基于MongoTemplate 开发CRUD"></a>4. 基于MongoTemplate 开发CRUD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;  </span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">alice</span> <span class="operator">=</span> mongoTemplate.insert(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">23</span>));  </span><br><span class="line">System.out.println(alice);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 查询全部  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findAll</span><span class="params">()</span> &#123;  </span><br><span class="line">List&lt;User&gt; all = mongoTemplate.findAll(User.class);  </span><br><span class="line">all.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 根据id查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mongoTemplate.findById(<span class="string">&quot;1&quot;</span>, User.class);  </span><br><span class="line">System.out.println(user);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 根据条件查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findByName</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line">List&lt;User&gt; users = mongoTemplate.find(query, User.class);  </span><br><span class="line">users.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 模糊查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findByNameLike</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).regex(<span class="string">&quot;A&quot;</span>));  </span><br><span class="line">List&lt;User&gt; users = mongoTemplate.find(query, User.class);  </span><br><span class="line">users.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 分页查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findByNameLikePage</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).regex(<span class="string">&quot;A&quot;</span>));  </span><br><span class="line">query.skip(<span class="number">0</span>).limit(<span class="number">2</span>);  </span><br><span class="line">List&lt;User&gt; users = mongoTemplate.find(query, User.class);  </span><br><span class="line">users.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 修改  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update1</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mongoTemplate.findOne(query, User.class);  </span><br><span class="line">user.setAge(<span class="number">24</span>);  </span><br><span class="line">mongoTemplate.save(user);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 修改  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update2</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line"><span class="type">Update</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Update</span>();  </span><br><span class="line">update.set(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);  </span><br><span class="line"><span class="type">UpdateResult</span> <span class="variable">upsert</span> <span class="operator">=</span> mongoTemplate.upsert(query, update, User.class);  </span><br><span class="line"><span class="type">long</span> <span class="variable">modifiedCount</span> <span class="operator">=</span> upsert.getModifiedCount();<span class="comment">//获取到修改受影响的行数  </span></span><br><span class="line">System.out.println(<span class="string">&quot;受影响的条数：&quot;</span>+modifiedCount);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 删除  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">remove</span> <span class="operator">=</span> mongoTemplate.remove(query, User.class);  </span><br><span class="line"><span class="type">long</span> <span class="variable">deletedCount</span> <span class="operator">=</span> remove.getDeletedCount();  </span><br><span class="line">System.out.println(<span class="string">&quot;删除的条数：&quot;</span>+deletedCount);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-基于-MongoRepository-开发-CRUD"><a href="#5-基于-MongoRepository-开发-CRUD" class="headerlink" title="5. 基于 MongoRepository 开发 CRUD"></a>5. 基于 MongoRepository 开发 CRUD</h3><p>Spring Data 提供了对 mongodb 数据访问的支持，我们只需要继承 MongoRepository 类，按照 Spring Data 规范就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;  </span><br><span class="line"><span class="comment">// 保存  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userRepository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Demon&quot;</span>, <span class="number">21</span>));  </span><br><span class="line">System.out.println(user1);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//查询所有  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findAll</span><span class="params">()</span>&#123;  </span><br><span class="line">List&lt;User&gt; lists = userRepository.findAll();  </span><br><span class="line">lists.forEach(System.out::println); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//根据id查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(<span class="string">&quot;2&quot;</span>).get();  </span><br><span class="line">System.out.println(user);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//条件查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserList</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">user.setName(<span class="string">&quot;Demon&quot;</span>);  </span><br><span class="line">user.setAge(<span class="number">21</span>);  </span><br><span class="line">Example&lt;User&gt; example = Example.of(user);  </span><br><span class="line">List&lt;User&gt; all = userRepository.findAll(example);  </span><br><span class="line">System.out.println(all);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//模糊条件查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findLikeUserList</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">///创建匹配器，即如何使用查询条件  </span></span><br><span class="line"><span class="type">ExampleMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> ExampleMatcher.matching()<span class="comment">//构建对象  </span></span><br><span class="line">.withStringMatcher(ExampleMatcher.StringMatcher.STARTING)<span class="comment">//改变默认字符串匹配方式：模糊查询  </span></span><br><span class="line">.withIgnoreCase(<span class="literal">true</span>);<span class="comment">//改变默认大小写忽略方式：忽略大小写  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">user.setName(<span class="string">&quot;De&quot;</span>);  </span><br><span class="line">user.setAge(<span class="number">21</span>);  </span><br><span class="line">Example&lt;User&gt; example = Example.of(user, matcher);  </span><br><span class="line">List&lt;User&gt; all = userRepository.findAll(example);  </span><br><span class="line">System.out.println(all);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//分页查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPageUserAll</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">//设置分页参数  </span></span><br><span class="line"><span class="comment">//0代表第一页  </span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">3</span>);  </span><br><span class="line"><span class="comment">//查询条件  </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">user.setName(<span class="string">&quot;Demon&quot;</span>);  </span><br><span class="line">user.setAge(<span class="number">21</span>);  </span><br><span class="line">Example&lt;User&gt; userExample = Example.of(user);<span class="comment">//查询条件  </span></span><br><span class="line">Page&lt;User&gt; page = userRepository.findAll(userExample, pageable);  </span><br><span class="line">System.out.println(page.getContent());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//修改操作  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">//先根据id出要修改的用户  </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(<span class="string">&quot;2&quot;</span>).get();  </span><br><span class="line"><span class="comment">//设置修改的值  </span></span><br><span class="line">user.setAge(<span class="number">24</span>);  </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userRepository.save(user);  </span><br><span class="line">System.out.println(user1);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//删除  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;  </span><br><span class="line">userRepository.deleteById(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Configuration和@Component 区别</title>
      <link href="/2023/05/08/%E5%90%8E%E7%AB%AF/Spring/@Configuration%E5%92%8C@Component%20%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/05/08/%E5%90%8E%E7%AB%AF/Spring/@Configuration%E5%92%8C@Component%20%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在@Component 类中使用方法或字段时不会使用 CGLIB 增强 (及不使用代理类：调用任何方法，使用任何变量，拿到的是原始对象，后面会有例子解释)。在@Component 中调用@Bean 注解的方法和字段则是普通的 Java 语义，不经过 CGLIB 处理。<br>而在@Configuration 类中使用方法或字段时则使用 CGLIB 创造协作对象（及使用代理：拿到的是代理对象）; 当调用@Bean 注解的方法时它不是普通的 Java 语义，而是从容器中拿到由 Spring 生命周期管理、被 Spring 代理甚至依赖于其他 Bean 的对象引用。</p></blockquote><p>@Configuration 本质上还是个@Component，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>  </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  </span><br><span class="line"><span class="meta">@Documented</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span>  </span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 中，对于配置类来讲是有分类的，大体可以分为两类，<strong>一类称为 LITE 模式，另一类称为 FULL 模式</strong>，那么对应上面的注解，@Component 就是 LITE 类型，@Configuration 就是 FULL 类型。</p><p><a href="https://zhuanlan.zhihu.com/p/607801167">Spring注解配置：@Configuration 和 @Component 区别及原理详解 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="/2023/04/26/%E6%9D%82%E9%A1%B9/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/04/26/%E6%9D%82%E9%A1%B9/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>hexo 官网：<a href="https://hexo.io/zh-cn/index.html">Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务解读</title>
      <link href="/2021/10/27/%E5%90%8E%E7%AB%AF/Spring/Spring%E4%BA%8B%E5%8A%A1%E8%A7%A3%E8%AF%BB/"/>
      <url>/2021/10/27/%E5%90%8E%E7%AB%AF/Spring/Spring%E4%BA%8B%E5%8A%A1%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>事务是处理逻辑原子性的保证，作为单个逻辑单元执行一系列操作，要么执行完成要么全部不执行。事务遵循 <strong>ACID四个特性</strong>。</p><ul><li><p>原子性：事务作为一个原子整体，要么执行要么完全不执行</p></li><li><p>一致性：事务保证数据库状态从一个一致性变为另一个一致性</p></li><li><p>隔离性：一个事务的执行不影响其他事务的执行</p></li><li><p>持久性：已经提交事务对数据的修改，应该永久保存在数据库</p></li></ul><p>事务的两个重要特性是，事务的传播特性和事务的隔离级别特性。传播级别决定了事务的控制范围，事务隔离级别决定了事务在数据库读写方面的控制范围。</p><h2 id="Transactional-注解解读"><a href="#Transactional-注解解读" class="headerlink" title="@Transactional 注解解读"></a>@Transactional 注解解读</h2><p>Transactional注解的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;<span class="comment">//传播类型</span></span><br><span class="line"></span><br><span class="line">    Isolation <span class="title function_">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT;<span class="comment">//隔离级别</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中传播类型有7种，每个传播类型的解读可查看《[带你读懂Spring 事务——事务的传播机制 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/148504094#:~:text=%E5%9C%A8Spring%E4%B8%AD%E5%AF%B9%E4%BA%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%83%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9A,REQUIRED%E3%80%81SUPPORTS%E3%80%81MANDATORY%E3%80%81REQUIRES_NEW%E3%80%81NOT_SUPPORTED%E3%80%81NEVER%E3%80%81NESTED">https://zhuanlan.zhihu.com/p/148504094#:~:text=在Spring中对于事务的传播行为定义了七种类型分别是：,REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED</a> 。)》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line">    REQUIRED(<span class="number">0</span>),<span class="comment">//如果当前没有事务，就新建一个事务，如果已经存在一个事务，则加入到这个事务中。这是事务注释的默认设置。</span></span><br><span class="line">    SUPPORTS(<span class="number">1</span>),<span class="comment">//当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行（比如方法里只有查询的时候）</span></span><br><span class="line">    MANDATORY(<span class="number">2</span>),<span class="comment">//当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</span></span><br><span class="line">    REQUIRES_NEW(<span class="number">3</span>),<span class="comment">//创建一个新事务，如果存在当前事务，则挂起该事务。</span></span><br><span class="line">    NOT_SUPPORTED(<span class="number">4</span>),<span class="comment">//始终以非事务方式执行,如果当前存在事务，则挂起当前事务</span></span><br><span class="line">    NEVER(<span class="number">5</span>),<span class="comment">//不使用事务，如果当前事务存在，则抛出异常</span></span><br><span class="line">    NESTED(<span class="number">6</span>);<span class="comment">//如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与REQUIRED类似的操作。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Propagation</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隔离级别有5种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> &#123;</span><br><span class="line">    DEFAULT(-<span class="number">1</span>), <span class="comment">//Spring建议的是使用DEFAULT，就是数据库本身的隔离级别，配置好数据库本身的隔离级别</span></span><br><span class="line">    READ_UNCOMMITTED(<span class="number">1</span>),<span class="comment">//读未提交</span></span><br><span class="line">    READ_COMMITTED(<span class="number">2</span>),<span class="comment">//读已提交</span></span><br><span class="line">    REPEATABLE_READ(<span class="number">4</span>),<span class="comment">//可重复读</span></span><br><span class="line">    SERIALIZABLE(<span class="number">8</span>);<span class="comment">//可串行化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Isolation</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**脏读(Drity Read)**：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li><strong>不可重复读(Non-repeatable read)</strong>:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li><strong>幻读(Phantom Read)</strong>:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><blockquote><p><strong>Mysql 默认采用的 REPEATABLE_READ隔离级别, Oracle 默认采用的 READ_COMMITTED隔离级别</strong></p></blockquote><h2 id="Transactional失效的场景"><a href="#Transactional失效的场景" class="headerlink" title="@Transactional失效的场景"></a><strong>@Transactional失效的场景</strong></h2><ol><li><p>@Transactional注解应用到非public方法（除非特殊配置，例如使用AspectJ 静态织入实现 AOP）</p></li><li><p>自调用，因为@Transactional是基于动态代理实现的</p></li><li><p>异常在代码中被你自己try catch了</p></li><li><p>异常类型不正确，默认只支持RuntimeException和Error，不支持检查异常</p></li><li><p>事务传播配置不符合业务逻辑</p></li><li><p>业务和spring事务代码必须不一个线程中</p></li><li><p>方法用final修饰</p></li><li><p>等，见下图</p><img src="https://pic1.zhimg.com/v2-63fcc7e79ed92ee604f1786e246f1afc_r.jpg" alt="preview" style="zoom:50%;" /></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis四大对象和生命周期</title>
      <link href="/2021/10/11/%E5%90%8E%E7%AB%AF/Mybatis/Mybatis%E5%9B%9B%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/10/11/%E5%90%8E%E7%AB%AF/Mybatis/Mybatis%E5%9B%9B%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mybatis.net.cn/getting-started.html">入门_MyBatis中文网</a></p><p><a href="http://www.mybatis.cn/archives/706.html">MyBatis的工作原理以及核心流程介绍 - MyBatis中文官网</a></p><table><thead><tr><th>对象</th><th>生命周期</th></tr></thead><tbody><tr><td>SqlSessionFactoryBuiler</td><td>方法局部(Method)使用完成即可被丢弃</td></tr><tr><td>SqlSessionFactory</td><td>应用级别(Application)，全局存在，是一个单例对象</td></tr><tr><td>SqlSession</td><td>请求或方法(Request&#x2F;Method)</td></tr><tr><td>Mapper</td><td>方法(Method)</td></tr></tbody></table><h3 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h3><p>理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。</p><hr><p><strong>提示</strong> <strong>对象生命周期和依赖注入框架</strong></p><p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。</p><hr><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p><h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中使用Lua脚本</title>
      <link href="/2021/10/09/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E4%B8%AD%E4%BD%BF%E7%94%A8Lua%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/10/09/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E4%B8%AD%E4%BD%BF%E7%94%A8Lua%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/77484377">Redis中使用Lua脚本（一） - 知乎 (zhihu.com)</a></p><p><a href="http://c.biancheng.net/view/4554.html">Redis中使用Lua语言 (biancheng.net)</a></p><p>只是在 Redis 中，执行 Lua 语言是原子性的，也就说 Redis 执行 Lua 的时候是不会被中断的，具备原子性，这个特性有助于 Redis 对并发数据一致性的支持。</p><p>Redis 支持两种方法运行脚本，一种是直接输入一些 Lua 语言的程序代码；另外一种是将 Lua 语言编写成文件。</p><p>在实际应用中，一些简单的脚本可以采取第一种方式，对于有一定逻辑的一般采用第二种方式。而对于采用简单脚本的，Redis 支持缓存脚本，只是它会使用 SHA-1 算法对脚本进行签名，然后把 SHA-1 标识返回回来，只要通过这个标识运行就可以了。</p><p>Redis使用Lua脚本的几个优点：<strong>减少网络开销、原子性、复用</strong></p><h2 id="Redis中Lua的常用命令"><a href="#Redis中Lua的常用命令" class="headerlink" title="Redis中Lua的常用命令"></a>Redis中Lua的常用命令</h2><p>命令不多，就下面这几个：<br>- EVAL<br>- EVALSHA<br>- SCRIPT LOAD - SCRIPT EXISTS<br>- SCRIPT FLUSH<br>- SCRIPT KILL</p><h3 id="EVAL命令"><a href="#EVAL命令" class="headerlink" title="EVAL命令"></a>EVAL命令</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval lua-script key-num [key1 key2 key3 ...] [value1 value2 value3 ...]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>eval 代表执行 Lua 语言的命令。</li><li>Lua-script 代表 Lua 语言脚本。</li><li>key-num 整数代表参数中有多少个 key，需要注意的是 Redis 中 key 是从 1 开始的，如果没有 key 的参数，那么写 0。</li><li>[key1key2key3…] 是 key 作为参数传递给 Lua 语言，也可以不填它是 key 的参数，但是需要和 key-num 的个数对应起来。</li><li>[value1 value2 value3…] 这些参数传递给 Lua 语言，它们是可填可不填的。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> <span class="number">2</span> key1 key2 first second </span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;second&quot;</span></span><br></pre></td></tr></table></figure><p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是： <code>redis.call() 和 redis.pcall()</code><br>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush foo a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; eval <span class="string">&quot;return redis.call(&#x27;get&#x27;, &#x27;foo&#x27;)&quot;</span> <span class="number">0</span></span><br><span class="line">(<span class="built_in">error</span>) ERR Error <span class="built_in">running</span> script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EVAL <span class="string">&quot;return redis.pcall(&#x27;get&#x27;, &#x27;foo&#x27;)&quot;</span> <span class="number">0</span></span><br><span class="line">(<span class="built_in">error</span>) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-LOAD命令-和-EVALSHA命令"><a href="#SCRIPT-LOAD命令-和-EVALSHA命令" class="headerlink" title="SCRIPT LOAD命令 和 EVALSHA命令"></a>SCRIPT LOAD命令 和 EVALSHA命令</h3><p>SCRIPT LOAD命令格式：<code>SCRIPT LOAD script</code><br>EVALSHA命令格式：<code>EVALSHA sha1 key-num key [key …] arg [arg …]</code></p><p>这两个命令放在一起讲的原因是：<code>EVALSHA</code> 命令中的sha1参数，就是<code>SCRIPT LOAD</code> 命令执行的结果。</p><p><code>SCRIPT LOAD</code> 将脚本 script 添加到Redis服务器的脚本缓存中，并不立即执行这个脚本，而是会立即对输入的脚本进行求值。并返回给定脚本的 SHA1 校验和。如果给定的脚本已经在缓存里面了，那么不执行任何操作。</p><p>在脚本被加入到缓存之后，在任何客户端通过<code>EVALSHA</code>命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行<code>SCRIPT FLUSH</code>为止。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## SCRIPT LOAD加载脚本，并得到sha1值</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCRIPT LOAD <span class="string">&quot;redis.call(&#x27;SET&#x27;, KEYS[1], ARGV[1]);redis.call(&#x27;EXPIRE&#x27;, KEYS[1], ARGV[2]); return 1;&quot;</span></span><br><span class="line"><span class="string">&quot;6aeea4b3e96171ef835a78178fceadf1a5dbe345&quot;</span></span><br><span class="line"></span><br><span class="line">## EVALSHA使用sha1值，并拼装和EVAL类似的numkeys和key数组、<span class="built_in">arg</span>数组，调用脚本。</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EVALSHA <span class="number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345 <span class="number">1</span> userAge <span class="number">10</span> <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get userAge</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl userAge</span><br><span class="line">(integer) <span class="number">43</span></span><br></pre></td></tr></table></figure><h3 id="SCRIPT-EXISTS-命令"><a href="#SCRIPT-EXISTS-命令" class="headerlink" title="SCRIPT EXISTS 命令"></a>SCRIPT EXISTS 命令</h3><p>命令格式：<code>SCRIPT EXISTS sha1 [sha1 …]</code><br>作用：给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中</p><h3 id="SCRIPT-FLUSH-命令"><a href="#SCRIPT-FLUSH-命令" class="headerlink" title="SCRIPT FLUSH 命令"></a>SCRIPT FLUSH 命令</h3><p>命令格式：<code>SCRIPT FLUSH</code><br>作用：清除Redis服务端所有 Lua 脚本缓存</p><h3 id="SCRIPT-KILL-命令"><a href="#SCRIPT-KILL-命令" class="headerlink" title="SCRIPT KILL 命令"></a>SCRIPT KILL 命令</h3><p>命令格式：<code>SCRIPT FLUSH</code><br>作用：杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p><h2 id="Redis执行Lua脚本文件"><a href="#Redis执行Lua脚本文件" class="headerlink" title="Redis执行Lua脚本文件"></a>Redis执行Lua脚本文件</h2><p>在第二章中介绍的命令，是在redis客户端中使用命令进行操作。该章节介绍的是直接执行 Lua 的脚本文件。</p><h4 id="编写Lua脚本文件"><a href="#编写Lua脚本文件" class="headerlink" title="编写Lua脚本文件"></a>编写Lua脚本文件</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val = redis.call(<span class="string">&quot;GET&quot;</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val == ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="执行Lua脚本文件"><a href="#执行Lua脚本文件" class="headerlink" title="执行Lua脚本文件"></a>执行Lua脚本文件</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行命令： redis-cli -a 密码 --eval Lua脚本路径 key [key …] ,  arg [arg …] </span><br><span class="line">如：redis-cli -a 123456 --eval ./Redis_CompareAndSet.lua userName , zhangsan lisi </span><br></pre></td></tr></table></figure><p><strong>此处敲黑板，注意啦！！！</strong><br>“–eval”而不是命令模式中的”eval”，一定要有前端的两个-<br>脚本路径后紧跟key [key …]，相比命令行模式，少了numkeys这个key数量值<br>key [key …] 和 arg [arg …] 之间的“ , ”，<strong>英文逗号前后必须有空格，否则死活都报错</strong></p><h2 id="JAVA中执行Lua"><a href="#JAVA中执行Lua" class="headerlink" title="JAVA中执行Lua"></a>JAVA中执行Lua</h2><p>这里通过RedisTemplate执行Lua，实现防止重复提交的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防重令牌验证（之前前端已经获取到了token，并且已经插入到redis中）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script, Long.class),Arrays.asList(RedisKeyConstant.CREATE_APP_TOKEN_PREFIX+userInfoTo.getUserId()), req.getAppToken());</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0L</span> == execute)&#123;</span><br><span class="line"><span class="keyword">return</span> R.error(RespEnum.CREATE_APP_REPEAT_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optional类</title>
      <link href="/2021/09/24/%E5%90%8E%E7%AB%AF/Java/Optional%E7%B1%BB/"/>
      <url>/2021/09/24/%E5%90%8E%E7%AB%AF/Java/Optional%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Optional</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure><p>可能包含或不包含非空值的容器对象。 如果一个值存在， <code>isPresent()</code>将返回<code>true</code>并且<code>get()</code>将返回值。</p><p>提供依赖于存在或不存在包含值的其他方法，例如<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Optional.html#orElse-T-"><code>orElse()</code></a> （如果值不存在则返回默认值）和<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Optional.html#ifPresent-java.util.function.Consumer-"><code>ifPresent()</code></a> （如果值存在<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Optional.html#ifPresent-java.util.function.Consumer-">则</a>执行代码块）。</p><p>这是一个<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/doc-files/ValueBased.html">value-based</a>类; 使用身份敏感的操作（包括引用相等（<code>==</code>），标识哈希码，或同步） <code>Optional</code>可具有不可预测的结果，应当避免。</p><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td align="left"><code>empty()</code><br/>返回一个空的 <code>Optional</code>实例。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>equals(Object obj)</code><br/>指示某个其他对象是否等于此可选项。</td></tr><tr><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"><code>filter(Predicate&lt;? super T&gt; predicate)</code><br>如果一个值存在，并且该值给定的谓词相匹配时，返回一个 <code>Optional</code>描述的值，否则返回一个空的 <code>Optional</code> 。</td></tr><tr><td align="left"><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td align="left"><code>flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</code><br/>如果一个值存在，应用提供的 <code>Optional</code>映射函数给它，返回该结果，否则返回一个空的 <code>Optional</code> 。</td></tr><tr><td align="left"><code>T</code></td><td align="left"><code>get()</code><br/>如果 <code>Optional</code>中有一个值，返回值，否则抛出 <code>NoSuchElementException</code> 。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>hashCode()</code><br/>返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code><br/>如果存在值，则使用该值调用指定的消费者，否则不执行任何操作。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isPresent()</code><br/>返回 <code>true</code>如果存在值，否则为 <code>false</code> 。</td></tr><tr><td align="left"><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td align="left"><code>map(Function&lt;? super T,? extends U&gt; mapper)</code><br/>如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个 <code>Optional</code>结果的 <code>Optional</code> 。</td></tr><tr><td align="left"><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td align="left"><code>of(T value)</code><br/>返回具有 <code>Optional</code>的当前非空值的Optional。</td></tr><tr><td align="left"><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td align="left"><code>ofNullable(T value)</code><br/>返回一个 <code>Optional</code>指定值的Optional，如果非空，则返回一个空的 <code>Optional</code> 。</td></tr><tr><td align="left"><code>T</code></td><td align="left"><code>orElse(T other)</code><br/>返回值如果存在，否则返回 <code>other</code> 。</td></tr><tr><td align="left"><code>T</code></td><td align="left"><code>orElseGet(Supplier&lt;? extends T&gt; other)</code><br/>返回值（如果存在），否则调用 <code>other</code>并返回该调用的结果。</td></tr><tr><td align="left"><code>&lt;X extends Throwable&gt;T</code></td><td align="left"><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code><br/>返回包含的值（如果存在），否则抛出由提供的供应商创建的异常。</td></tr><tr><td align="left"><code>String</code></td><td align="left"><code>toString()</code><br/>返回此可选的非空字符串表示，适用于调试。</td></tr></tbody></table><ul><li><h3 id="从-java-lang-Object类继承的方法"><a href="#从-java-lang-Object类继承的方法" class="headerlink" title="从 java.lang.Object类继承的方法"></a>从 java.lang.<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Object.html">Object</a>类继承的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone, finalize, getClass, notify, notifyAll, wait, wait, wait</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream</title>
      <link href="/2021/09/23/%E5%90%8E%E7%AB%AF/Java/Java8-Stream/"/>
      <url>/2021/09/23/%E5%90%8E%E7%AB%AF/Java/Java8-Stream/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/mu_wind/article/details/109516995">这里引用一个Stream的博客</a></p><p><img src="http://qiniu.c77544s.top/picgo/202210121453117.png" alt="Java Stream流"></p><p><code>Stream</code> 可以由数组或集合创建，对流的操作分为两种：</p><p>中间操作，每次返回一个新的流，可以有多个。<br>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。<br>另外，<code>Stream</code>有几个特性：</p><ol><li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li><li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</li><li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ol><h1 id="Stream的创建方式"><a href="#Stream的创建方式" class="headerlink" title="Stream的创建方式"></a>Stream的创建方式</h1><h2 id="1、通过-java-util-Collection-stream-方法用集合创建流"><a href="#1、通过-java-util-Collection-stream-方法用集合创建流" class="headerlink" title="1、通过 java.util.Collection.stream() 方法用集合创建流"></a>1、通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// 创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure><h2 id="2、使用java-util-Arrays-stream-T-array-方法用数组创建流"><a href="#2、使用java-util-Arrays-stream-T-array-方法用数组创建流" class="headerlink" title="2、使用java.util.Arrays.stream(T[] array)方法用数组创建流"></a>2、使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(array);</span><br></pre></td></tr></table></figure><h2 id="3、使用Stream的静态方法：of-、iterate-、generate"><a href="#3、使用Stream的静态方法：of-、iterate-、generate" class="headerlink" title="3、使用Stream的静态方法：of()、iterate()、generate()"></a>3、使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>);</span><br><span class="line">stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h1 id="Stream的使用"><a href="#Stream的使用" class="headerlink" title="Stream的使用"></a>Stream的使用</h1><h2 id="遍历-x2F-匹配"><a href="#遍历-x2F-匹配" class="headerlink" title="遍历&#x2F;匹配"></a>遍历&#x2F;匹配</h2><p><code>forEach()</code> <code>findFirst()</code> <code>findAny()</code> <code>anyMatch()</code> <code>allMatch</code> <code>noneMatch()</code></p><h2 id="筛选-x2F-过滤"><a href="#筛选-x2F-过滤" class="headerlink" title="筛选&#x2F;过滤"></a>筛选&#x2F;过滤</h2><p><code>filter()</code></p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><code>max()</code> <code>min()</code> <code>count()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">Optional&lt;Integer&gt; max2 = list.stream().max(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).count();</span><br></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><code>map</code> <code>flatMap</code></p><ul><li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;m,k,l,a&quot;</span>, <span class="string">&quot;1,3,5,7&quot;</span>);</span><br><span class="line">List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">  <span class="comment">// 将每个元素转换成一个stream</span></span><br><span class="line">  String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">  <span class="keyword">return</span> s2;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>结果：[m, k, l, a, 1, 3, 5]</p></blockquote><h2 id="规约（reduce）"><a href="#规约（reduce）" class="headerlink" title="规约（reduce）"></a>规约（reduce）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sumSalary1</span> <span class="operator">=</span> personList.stream().map(Person::getSalary).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">Optional&lt;Integer&gt; sumSalary2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sumSalary3</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);</span><br></pre></td></tr></table></figure><h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><p><code>collect</code>，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。</p><blockquote><p><code>collect</code>主要依赖<code>java.util.stream.Collectors</code>类内置的静态方法。</p></blockquote><h3 id="归集-toList-x2F-toSet-x2F-toMap"><a href="#归集-toList-x2F-toSet-x2F-toMap" class="headerlink" title="归集(toList&#x2F;toSet&#x2F;toMap)"></a>归集(toList&#x2F;toSet&#x2F;toMap)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toSet());</span><br><span class="line">Map&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="number">8000</span>).collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br></pre></td></tr></table></figure><h3 id="统计-count-x2F-averaging"><a href="#统计-count-x2F-averaging" class="headerlink" title="统计(count&#x2F;averaging)"></a>统计(count&#x2F;averaging)</h3><p><code>Collectors</code>提供了一系列用于数据统计的静态方法：</p><ul><li>计数：<code>count</code></li><li>平均值：<code>averagingInt</code>、<code>averagingLong</code>、<code>averagingDouble</code></li><li>最值：<code>maxBy</code>、<code>minBy</code></li><li>求和：<code>summingInt</code>、<code>summingLong</code>、<code>summingDouble</code></li><li>统计以上所有：<code>summarizingInt</code>、<code>summarizingLong</code>、<code>summarizingDouble</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求总数</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> personList.stream().collect(Collectors.counting());</span><br><span class="line"><span class="comment">// 求平均工资</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">average</span> <span class="operator">=</span> personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class="line"><span class="comment">// 求最高工资</span></span><br><span class="line">Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class="line"><span class="comment">// 求工资之和</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line"><span class="comment">// 一次性统计所有信息</span></span><br><span class="line"><span class="type">DoubleSummaryStatistics</span> <span class="variable">collect</span> <span class="operator">=</span> personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br></pre></td></tr></table></figure><h3 id="分区-x2F-分组-partitioningBy-x2F-groupingBy"><a href="#分区-x2F-分组-partitioningBy-x2F-groupingBy" class="headerlink" title="分区&#x2F;分组(partitioningBy&#x2F;groupingBy)"></a>分区&#x2F;分组(partitioningBy&#x2F;groupingBy)</h3><ul><li>分区：将<code>stream</code>按条件分为两个<code>Map</code>，比如员工按薪资是否高于8000分为两部分。</li><li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将员工按薪资是否高于8000分组</span></span><br><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; <span class="number">8000</span>));</span><br><span class="line"><span class="comment">// 将员工按性别分组</span></span><br><span class="line">Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class="line"><span class="comment">// 将员工先按性别分组，再按地区分组</span></span><br><span class="line">Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br></pre></td></tr></table></figure><h3 id="接合-joining"><a href="#接合-joining" class="headerlink" title="接合(joining)"></a>接合(joining)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="归约-reducing"><a href="#归约-reducing" class="headerlink" title="归约(reducing)"></a>归约(reducing)</h3><p><code>Collectors</code>类提供的<code>reducing</code>方法，相比于<code>stream</code>本身的<code>reduce</code>方法，增加了对自定义归约的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (i, j) -&gt; (i + j - <span class="number">5000</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;员工扣税薪资总和：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stream的reduce</span></span><br><span class="line">Optional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">System.out.println(<span class="string">&quot;员工薪资总和：&quot;</span> + sum2.get());</span><br></pre></td></tr></table></figure><h2 id="排序-sorted"><a href="#排序-sorted" class="headerlink" title="排序(sorted)"></a>排序(sorted)</h2><p>sorted，中间操作。有两种排序：</p><ul><li>sorted()：自然排序，流中元素需实现Comparable接口</li><li>sorted(Comparator com)：Comparator排序器自定义排序</li></ul><h2 id="提取-x2F-组合"><a href="#提取-x2F-组合" class="headerlink" title="提取&#x2F;组合"></a>提取&#x2F;组合</h2><p><code>distinct()</code> <code>limit()</code> <code>skip()</code></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis笔记</title>
      <link href="/2021/09/17/%E5%90%8E%E7%AB%AF/Mybatis/Mybatis%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/17/%E5%90%8E%E7%AB%AF/Mybatis/Mybatis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="SqlSession-一级缓存的工作流程："><a href="#SqlSession-一级缓存的工作流程：" class="headerlink" title="SqlSession 一级缓存的工作流程："></a>SqlSession 一级缓存的工作流程：</h3><ol><li>对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果</li><li>判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；</li><li>如果命中，则直接将缓存结果返回；</li><li>如果没命中：<ol><li>去数据库中查询数据，得到查询结果；</li><li>将key和查询到的结果分别作为key,value对存储到Cache中；</li><li>将查询结果返回；</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同Session</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">session1</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> session1.getMapper(BlogMapper.class);</span><br><span class="line">System.out.println(mapper1.selectBlogById(<span class="number">1002</span>));</span><br><span class="line">System.out.println(mapper1.selectBlogById(<span class="number">1002</span>));</span><br></pre></td></tr></table></figure><p>上述代码只会有一次查询数据库的操作</p><h3 id="一级缓存的不足："><a href="#一级缓存的不足：" class="headerlink" title="一级缓存的不足："></a><strong>一级缓存的不足：</strong></h3><p>　　使用一级缓存的时候，因为缓存不能跨会话共享，不同的会话之间对于相同的数据可能有不一样的缓存。在有多个会话或者分布式环境下，会存在脏数据的问题。如果要解决这个问题，就要用到二级缓存。MyBatis 一级缓存（MyBaits 称其为 Local Cache）无法关闭，但是有两种级别可选：</p><ol><li>session 级别的缓存，在同一个 sqlSession 内，对同样的查询将不再查询数据库，直接从缓存中。</li><li>statement 级别的缓存，避坑： 为了避免这个问题，可以将一级缓存的级别设为 statement 级别的，这样每次查询结束都会清掉一级缓存。</li></ol><h3 id="开启二级缓存的方法"><a href="#开启二级缓存的方法" class="headerlink" title="开启二级缓存的方法"></a><strong>开启二级缓存的方法</strong></h3><p>第一步：配置 mybatis.configuration.cache-enabled&#x3D;true，只要没有显式地设置cacheEnabled&#x3D;false，都会用CachingExecutor 装饰基本的执行器。</p><p>第二步：在Mapper.xml 中配置<cache/>标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span><br><span class="line">    size=&quot;1024&quot;</span><br><span class="line">    eviction=&quot;LRU&quot;</span><br><span class="line">    flushInterval=&quot;120000&quot;</span><br><span class="line">    readOnly=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure><p>基本上就是这样。这个简单语句的效果如下:</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读&#x2F;写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><h3 id="什么时候开启二级缓存？"><a href="#什么时候开启二级缓存？" class="headerlink" title="什么时候开启二级缓存？"></a><strong>什么时候开启二级缓存</strong>？</h3><p>一级缓存默认是打开的，二级缓存需要配置才可以开启。那么我们必须思考一个问题，在什么情况下才有必要去开启二级缓存？</p><ol><li>因为所有的增删改都会刷新二级缓存，导致二级缓存失效，所以适合在查询为主的应用中使用，比如历史交易、历史订单的查询。否则缓存就失去了意义。</li><li>如果多个namespace 中有针对于同一个表的操作，比如Blog 表，如果在一个namespace 中刷新了缓存，另一个namespace 中没有刷新，就会出现读到脏数据的情况。所以，推荐在一个Mapper 里面只操作单表的情况使用。</li></ol><p>　　如果要让多个namespace 共享一个二级缓存，应该怎么做？跨namespace 的缓存共享的问题，可以使用<code>&lt;cache-ref&gt;</code>来解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache-ref namespace=&quot;com.wuzz.crud.dao.DepartmentMapper&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized 的锁升级机制</title>
      <link href="/2021/09/16/%E5%90%8E%E7%AB%AF/Java/synchronized-%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/09/16/%E5%90%8E%E7%AB%AF/Java/synchronized-%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="http://qiniu.c77544s.top/picgo/202210121457816.png" alt="synchronized锁升级流程图"></p><p>Synchronized关键字可以用来修饰方法或者代码块。对于同步方法，JVM 采用 ACC_SYNCHRONIZED 标记符来实现同步。 对于同步代码块。JVM 采用 monitorenter、monitorexit 两个指令来实现同步。</p><p>在JDK1.6之后对对synchronized锁进行了升级，在1.6之前synchronized直接加重量级锁，但是1.6之后对其性能进行了优化，采用锁升级的机制：偏向锁-&gt;自旋锁(轻量级锁)-&gt;重量级锁。</p><p>初次执行到synchronized代码块的时候，锁对象变成偏向锁。线程执行并不会主动释放锁。第二次到达代码块的时候，线程会判断之前的线程是不是自己，如果是自己的话，由于前面没有释放锁的操作，这里也就不用重新加锁，就没有加锁、解锁的开销了。</p><p>当第二个线程过来，两个线程产生了竞争，就会从偏向锁升级成自旋锁。自旋锁竞争状态中，没有获得锁的线程，就会不断自旋判断自己是否拿到了锁，没有拿到锁就会忙等。</p><h2 id="偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h2><p>这三种锁是指锁的状态，并且是针对Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段mark word来表明的。</p><ul><li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。也就是说一个对象在被初始化后，如果还没有任何线程来获取它的锁时，它就是可偏向的，当有第一个线程来访问它尝试获取锁的时候，它就记录下来这个线程，如果后面尝试获取锁的线程正是这个偏向锁的拥有者，就可以直接获取锁，开销很小。</li><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低(因为唤醒该线程，需要操作系统的帮忙，也就是涉及到用户态和内核态的切换，转换状态比较耗时，所以重量级锁开销很大)。</li></ul><p>总共有4种锁状态，级别由低到高依次为：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>。这几个状态会随着竞争情况逐渐升级。</p><p>注意：锁可以升级但不能降级。</p><p><img src="http://qiniu.c77544s.top/picgo/202210121457818.png" alt="img"></p><h2 id="Java-对象头和-Monitor"><a href="#Java-对象头和-Monitor" class="headerlink" title="Java 对象头和 Monitor"></a>Java 对象头和 Monitor</h2><p>在使用 synchronized 来同步代码块的时候，经编译后，会在代码块的起始位置插入 <strong>monitorenter指令</strong>，在结束或异常处插入 <strong>monitorexit指令。</strong>当执行到 monitorenter 指令时，将会尝试获取对象所对应的 **monitor **的所有权，即尝试获得对象的锁。而 synchronized 用的锁是存放在 <strong>Java对象头</strong> 中的。</p><p>所以引出了两个关键词：“Java 对象头” 和 “Monitor”。</p><h4 id="1、Java-对象头"><a href="#1、Java-对象头" class="headerlink" title="1、Java 对象头"></a>1、Java 对象头</h4><p>我们以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="2、Monitor"><a href="#2、Monitor" class="headerlink" title="2、Monitor"></a>2、Monitor</h4><p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。</p><p>Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><h2 id="3种锁对比"><a href="#3种锁对比" class="headerlink" title="3种锁对比"></a>3种锁对比</h2><p>偏向锁通过对比 Mark Word 解决加锁问题，避免执行CAS操作。</p><p>轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</p><p>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><p>转自：<a href="https://www.cnblogs.com/shuiyj/p/13121393.html">图解 synchronized 的锁升级机制</a>、<a href="https://www.jianshu.com/p/d61f294ac1a6">synchronized四种锁状态的升级</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC笔记</title>
      <link href="/2021/09/14/%E5%90%8E%E7%AB%AF/Java/JUC%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/14/%E5%90%8E%E7%AB%AF/Java/JUC%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Interface-Lock"><a href="#Interface-Lock" class="headerlink" title="Interface Lock"></a>Interface Lock</h2><blockquote><p>All Known Implementing Classes:</p><p>ReentrantLock、ReentrantReadWriteLock.ReadLock、ReentrantReadWriteLock.WriteLock</p></blockquote><p>公平锁：先来后到</p><p><strong>非公平锁：可以插队（插队）</strong></p><p><img src="http://qiniu.c77544s.top/picgo/202210121454118.png" alt="image-20210914101016223"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">   <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">         notFull.await();</span><br><span class="line">       items[putptr] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">       ++count;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">         notEmpty.await();</span><br><span class="line">       <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> items[takeptr];</span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">       --count;</span><br><span class="line">       notFull.signal();</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h2><p>8个关于锁的问题</p><p>如何判断锁是谁，锁到底锁的是谁</p><p>普通的synchronized方法锁的对象是方法的调用者，也就是调用方法的实例化变量</p><p>静态的（static）synchronized方法锁的对象是方法的调用者，也就是类</p><h2 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h2><p><strong>java.util.ConcurrentModificationException</strong>   <strong>并发修改异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//并发下ArrayList不安全</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[75795]</span><br><span class="line">[75795, 71586, 39235]</span><br><span class="line">[75795, 71586]</span><br><span class="line">[75795]</span><br><span class="line">[75795, 71586, 39235, 6ab3e, af04b]</span><br><span class="line">[75795, 71586, 39235, 6ab3e, af04b, 50f74, 3bef9, 37d5a, 408b2]</span><br><span class="line">[75795, 71586, 39235, 6ab3e]</span><br><span class="line">Exception in thread &quot;5&quot; Exception in thread &quot;1&quot; Exception in thread &quot;6&quot; java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p><strong>解决方案1:使用Vector，但是已经过时不使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();<span class="comment">//Vector是线程安全的</span></span><br></pre></td></tr></table></figure><p><strong>解决方案2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><p><strong>解决方案3:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p> <strong>CopyOnWrite写入时复制</strong>，COW，计算机设计领域的一种优化策略</p><p>多个线程调用的时候，list，读取的是固定的，写入（覆盖）</p><p>在写入的时候避免覆盖，造成数据问题</p><p>读写分离</p><p><strong>CopyOnWriteArrayList 比 Vector厉害在哪？</strong></p><p>Vector使用synchronized性能低，CopyOnWriteArrayList使用ReentrantLock锁性能更高，如下为CopyOnWriteArrayList的add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//复制一份</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Set同理，可以使用CopyOnWriteArraySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">common</span> <span class="operator">=</span> Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap可以使用ConcurrentHashMap</strong></p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p><img src="http://qiniu.c77544s.top/picgo/202210121454707.png" alt="image-20210914120526410"></p><p>1、可以有返回值</p><p>2、可以有异常</p><p>3、方法不同，call()</p><p><strong>Callable如何启动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()).start();</span><br><span class="line"><span class="number">2.</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;V&gt;()).start();<span class="comment">//FutureTask extends Runnable,所以与第一种等价</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;V&gt;( Callable )).start();<span class="comment">//传入Callable</span></span><br><span class="line"></span><br><span class="line">futureTask.get();<span class="comment">//可获取线程的返回值， get方法可能会产生阻塞</span></span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><p>1、有缓存</p><p>2、结果可能需要等待，会阻塞</p><h2 id="常用辅助类（必会）"><a href="#常用辅助类（必会）" class="headerlink" title="常用辅助类（必会）"></a>常用辅助类（必会）</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="http://qiniu.c77544s.top/picgo/202210121454709.png" alt="image-20210914122508404"></p><p><strong>原理：</strong></p><p><code>countDownLatch.countDown();</code>&#x2F;&#x2F;数量-1</p><p><code>countDownLatch.await();</code>&#x2F;&#x2F;计数器归零</p><p>每有一个线程，就将计数器-1，只有计数器变为0时，await方法才会被唤醒，继续执行</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p><strong>CountDownLatch是减法计数器，CyclicBarrier是加法计数器</strong></p><p><img src="http://qiniu.c77544s.top/picgo/202210121454710.png" alt="image-20210914123027943"></p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量</p><p><img src="http://qiniu.c77544s.top/picgo/202210121454711.png" alt="image-20210914123559007"></p><p>原理：</p><p><code>semaphore.acquire();</code>获得，如果已经满了，等待到释放为止</p><p><code>semaphore..release();</code>释放，会将当前的信号量释放+1，然后唤醒等待的线程</p><p>作用：多个共享资源的互斥使用！并发限流，控制最大的线程数！</p><h2 id="ReadWriteLock锁"><a href="#ReadWriteLock锁" class="headerlink" title="ReadWriteLock锁"></a>ReadWriteLock锁</h2><p><strong>独占锁（写锁）</strong>，一次只能由一个线程占有</p><p><strong>共享锁（读锁）</strong>，多个线程可以同时占有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; myCache.put(temp + <span class="string">&quot;&quot;</span>, temp), String.valueOf(temp)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; myCache.get(temp + <span class="string">&quot;&quot;</span>), String.valueOf(temp)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读写锁：更加细粒度的控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入的时候只希望同时只有一个线程写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入&quot;</span> + key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(<span class="string">&quot;写入ok&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读可以多个进程读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取&quot;</span> + key);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取ok&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><p><img src="http://qiniu.c77544s.top/picgo/202210121454712.png" alt="image-20210914132752107"></p><p><strong>什么情况下使用阻塞队列？多线程、线程池</strong></p><h3 id="四组API"><a href="#四组API" class="headerlink" title="四组API"></a>四组API</h3><p><img src="http://qiniu.c77544s.top/picgo/202210121454713.png" alt="image-20210914134127928"></p><h3 id="SynchronousQueue同步队列"><a href="#SynchronousQueue同步队列" class="headerlink" title="SynchronousQueue同步队列"></a>SynchronousQueue同步队列</h3><p>没有容量，进去一个元素，必须等待取出来之后，才能往里边存元素</p><p>put、take</p><h2 id="线程池（重点）"><a href="#线程池（重点）" class="headerlink" title="线程池（重点）"></a>线程池（重点）</h2><p>线程池：三大方法、7大参数、4种拒绝策略</p><p><img src="http://qiniu.c77544s.top/picgo/202210121454714.png" alt="image-20210914135622257"></p><h3 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h3><p><img src="http://qiniu.c77544s.top/picgo/202210121454715.png" alt="image-20210914135502709"></p><h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="comment">//0到最大</span></span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的初始参数创建一个新的ThreadPoolExecutor 。</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * corePoolSize – 要保留在池中的线程数，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment"> * maximumPoolSize – 池中允许的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime – 当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间。</span></span><br><span class="line"><span class="comment"> * unit – keepAliveTime参数的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue – 用于在执行任务之前保存任务的队列。 这个队列将只保存execute方法提交的Runnable任务。</span></span><br><span class="line"><span class="comment"> * threadFactory – 执行程序创建新线程时使用的工厂</span></span><br><span class="line"><span class="comment"> * handler – 执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, //核心线程大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, //最大核心线程大小</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, //超时没人调用就会释放</span></span><br><span class="line"><span class="params">                          TimeUnit unit, //超时单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程工厂，创建线程的</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123; <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.c77544s.top/picgo/202210121454716.png" alt="image-20210914140930465"></p><p><strong>既然上面创建线程池的方法不可用，那么怎么创建线程呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程池，因为工具类创建线程池不安全</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">3</span>,<span class="comment">//除核心线程之外的线程，如果没有使用的话3秒后释放线程</span></span><br><span class="line">        TimeUnit.SECONDS,  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="comment">//（默认拒绝策略）银行满了，还有人进来，就不处理这个人的，并且跑出异常</span></span><br></pre></td></tr></table></figure><h3 id="四大拒绝策略"><a href="#四大拒绝策略" class="headerlink" title="四大拒绝策略"></a>四大拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy();<span class="comment">//（默认拒绝策略）银行满了，还有人进来，就不处理这个人的，并且跑出异常</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy();<span class="comment">// 哪来的去哪里,比如如果是main线程调用线程池，超出后，由main线程处理 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy();<span class="comment">// 队列满了不回抛出异常，丢掉任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy();<span class="comment">// 队列满了不回抛出异常，尝试和最早的竞争，竞争失败就丢掉任务</span></span><br></pre></td></tr></table></figure><h3 id="最大线程该怎么定义（maximumPoolSize）"><a href="#最大线程该怎么定义（maximumPoolSize）" class="headerlink" title="最大线程该怎么定义（maximumPoolSize）"></a>最大线程该怎么定义（maximumPoolSize）</h3><p>1、CPU密集型, 几核就是几，保证效率最高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure><p>2、IO密集型，&gt; 判断你程序中十分耗IO的线程</p><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin 在jdk 1.7中， 并行执行任务，提高效率，大数据量    类似于MapReduce</p><blockquote><p>ForkJoin特点：工作窃取</p></blockquote><p>这个里边维护的都是双端队列</p><p>1、ForkJoinPool 通过它来执行</p><p>2、计算任务 <code>forkJoinPool.execute(ForkJoinTask&lt;?&gt; task);</code></p><p>3、 计算类要继承ForkJoinTask</p><p><img src="http://qiniu.c77544s.top/picgo/202210121454717.png" alt="image-20210914150111885"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">100_0000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &gt; temp) &#123; <span class="comment">//forkjoin</span></span><br><span class="line">            <span class="comment">// 分支合并计算</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            task1.fork();<span class="comment">//差分任务，把任务压入线程队列</span></span><br><span class="line">            task2.fork();<span class="comment">//差分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">ForkJoinDemo</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        <span class="comment">// forkJoinPool.execute(task);</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum:&quot;</span> + sum + <span class="string">&quot;时间：&quot;</span> + (endTime-startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更快</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并行流计算 （）（]</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum:&quot;</span> + sum + <span class="string">&quot;时间：&quot;</span> + (endTime-startTime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum:500000000500000000时间：539</span><br><span class="line">sum:500000000500000000时间：154</span><br></pre></td></tr></table></figure><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><blockquote><p>Future 设计的初衷，对将来的某个时间点结果进行建模</p></blockquote><img src="http://qiniu.c77544s.top/picgo/202210121454718.png" alt="image-20210914152652025" style="zoom:70%;"/><p>&#x2F;&#x2F;异步执行</p><p>&#x2F;&#x2F;成功回调</p><p>&#x2F;&#x2F;失败回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="comment">// 发起请求,runAsync没有返回值的异步回调</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;runAsync=&gt;Void&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//supplyAsync有返回结果的异步回调</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;completableFuture2&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// System.out.println(completableFuture2.get());//获取completableFuture2的值，会阻塞</span></span><br><span class="line">    <span class="comment">// System.out.println(completableFuture.get());//获取completableFuture的值，会阻塞</span></span><br><span class="line"></span><br><span class="line">    System.out.println(completableFuture2.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t=&gt;&quot;</span> + t);<span class="comment">// 正常的返回结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;u=&gt;&quot;</span> + u);<span class="comment">// 错误信息 java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line">    &#125;).exceptionally(throwable -&gt; &#123; <span class="comment">// 处理异常</span></span><br><span class="line">        System.out.println(throwable.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;).get());</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p><strong>什么是JMM</strong></p><p>java内存模型</p><p>关于JMM的一些约定：</p><p>1、线程解锁前，必须把共享变量立刻刷回主存</p><p>2、线程加锁前，必须读取主存中的最新值到工作内存中</p><p>3、加锁和解锁是同一把锁</p><img src="http://qiniu.c77544s.top/picgo/202210121454719.png" alt="image-20210914165252630" style="zoom:50%;" /><img src="http://qiniu.c77544s.top/picgo/202210121454720.png" alt="image-20210914165402592" style="zoom:50%;" /><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>什么是Volatile？java虚拟机提供的<strong>轻量级同步机制</strong></p><p>1、保证可见性e</p><p><strong>2、不保证原子性</strong></p><p>如果不加lock或synchronized，怎样保证原子性？见下一节，比锁高效很多</p><blockquote><p>使用原子类进行原子操作 </p></blockquote><p><strong>num++ 不是一个原子性操作</strong>，num++操作步骤是啥?</p><ul><li>获得这个值</li><li>+1 </li><li>写回这个值</li></ul><p>3、禁止指令重排</p><blockquote><p>什么是指令重排</p></blockquote><p>源代码—&gt;编译器优化可能重排—&gt;指令并行也可能重排—&gt;内存系统也会重排—&gt;执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> y=<span class="number">2</span>;<span class="comment">//2</span></span><br><span class="line">x=x+<span class="number">5</span>;<span class="comment">//3</span></span><br><span class="line">y=x*x;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">我们期望：<span class="number">1234</span> ， 但是<span class="number">2134</span>也是对的，<span class="number">1324</span>也是对的，但是<span class="number">4123</span>不对，因为<span class="number">4</span>依赖于<span class="number">1</span></span><br></pre></td></tr></table></figure><p>可能造成的结果</p><img src="http://qiniu.c77544s.top/picgo/202210121454721.png" alt="image-20210914172349897" style="zoom:50%;" /><blockquote><p> Volatile如何避免内存重排</p></blockquote><img src="http://qiniu.c77544s.top/picgo/202210121454722.png" alt="image-20210914172549903" style="zoom:50%;" /><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">num.getAndIncrement();<span class="comment">//AtomicInteger + 1 方法，CAS操作</span></span><br></pre></td></tr></table></figure><p>getAndIncrement如何实现的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层和操作系统挂钩！在操作系统中修改值！Unsafe是个很特殊的存在</p><h2 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h2><blockquote><p>什么是CAS</p></blockquote><p><strong>CAS：compareAndSet 的缩写</strong></p><p><a href="https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/juc/%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E7%9A%84CAS%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97.md">详情见GitHub上的八股文</a></p><img src="http://qiniu.c77544s.top/picgo/202210121454723.png" alt="image-20210914175225956" style="zoom:50%;" /><p>CAS：比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作，否则一直循环（自旋锁），直到是期望的值</p><p>缺点：</p><p>1、循环会耗时</p><p>2、一次性只能保证一个共享变量的原子性</p><p>3、ABA问题</p><blockquote><p>CAS :  ABA问题（狸猫换太子）</p></blockquote><img src="http://qiniu.c77544s.top/picgo/202210121454724.png" alt="image-20210914175739576" style="zoom:80%;" /><p>右边的线程，将1换成3，又将3换成1，而左边的线程不知道，看还是1。</p><p>这个是我们不期望的，我们期望，不能让别人动</p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>待版本号的原子操作</p><p>类似于我们平时sql里边的乐观锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;T&gt; xx = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//第一个参数initialRef（期望值）,第二个参数initialStamp（乐观锁的标志）</span></span><br></pre></td></tr></table></figure><h2 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h2><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><p>公平锁：先来后到</p><p><strong>非公平锁：可以插队（插队）</strong>（默认）</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁（递归锁）</p><img src="http://qiniu.c77544s.top/picgo/202210121454725.png" alt="image-20210914181528815" style="zoom:50%;" /><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>Spinlock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>1、使用<code>jps -l</code> 定位进程号(jdk bin目录下)</p><img src="http://qiniu.c77544s.top/picgo/202210121454726.png" alt="image-20210914182634792" style="zoom:50%;" /><p>2、使用<code>jstack 进程号</code>找到死锁问题</p><img src="http://qiniu.c77544s.top/picgo/202210121454727.png" alt="image-20210914182803167" style="zoom:50%;" /><p>工作中排查问题：</p><p>1、日志</p><p>2、堆栈信息</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程1</title>
      <link href="/2021/09/13/%E5%90%8E%E7%AB%AF/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B1/"/>
      <url>/2021/09/13/%E5%90%8E%E7%AB%AF/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h2 id="停止线程："><a href="#停止线程：" class="headerlink" title="停止线程："></a>停止线程：</h2><ul><li>不推荐使用JDK提供的stop()、destroy()、方法</li><li>推荐线程自己停下来</li><li>建议使用一个标志位终止变量，当flag&#x3D;false，则终止线程运行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread...run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CreateThreadRunnable</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateThreadRunnable</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(p).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">99</span>) &#123;</span><br><span class="line">                p.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h2><p>sleep()，一半不用sleep，而是用JUC下的 <strong><code>TimeUnit.DAY.sleep(1);</code></strong> 方法</p><p>yield()</p><ul><li>线程礼让，让当前线程暂停，但是不阻塞</li><li>运行状态到就绪状态</li><li><strong>让CPU重新调度，礼让不一定成功，看CPU心情</strong></li></ul><p>join()</p><ul><li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li><li>可以想象成插队</li></ul><p>Thread.state 查看线程状态 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尚未启动的线程的线程状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行线程的线程状态。 处于可运行状态的线程正在 Java 虚拟机中执行，</span></span><br><span class="line"><span class="comment">         * 但它可能正在等待来自操作系统的其他资源，例如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程阻塞等待监视器锁的线程状态。 处于阻塞状态的线程正在等待监视器锁进入同步块/方法</span></span><br><span class="line"><span class="comment">         * 或在调用Object.wait后重新进入同步块/方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待线程的线程状态。 由于调用以下方法之一，线程处于等待状态：</span></span><br><span class="line"><span class="comment">         * Object.wait没有超时</span></span><br><span class="line"><span class="comment">         * Thread.join没有超时</span></span><br><span class="line"><span class="comment">         * LockSupport.park</span></span><br><span class="line"><span class="comment">         * 处于等待状态的线程正在等待另一个线程执行特定操作。 </span></span><br><span class="line"><span class="comment">         * 例如，在对象上调用Object.wait()的线程正在等待另一个线程在该对象上</span></span><br><span class="line"><span class="comment">         * 调用Object.notify()或Object.notifyAll() 。 调用Thread.join() 的线程正在等待指定的线程终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 具有指定等待时间的等待线程的线程状态。 由于使用指定的正等待时间调用以下方法之一，线程处于定时等待状态：</span></span><br><span class="line"><span class="comment">         * Thread.sleep</span></span><br><span class="line"><span class="comment">         * Object.wait超时</span></span><br><span class="line"><span class="comment">         * Thread.join超时</span></span><br><span class="line"><span class="comment">         * LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">         * LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 终止线程的线程状态。 线程已完成执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.c77544s.top/picgo/202210121452267.png" alt="image-20210913151519171"></p><p><strong>thread.setDaemon(true) 设置线程为守护线程</strong></p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>synchronized 方法、代码块，锁的对象需要是变化的量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList 线程安全的集合</span><br></pre></td></tr></table></figure><h3 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h3><p><img src="http://qiniu.c77544s.top/picgo/202210121452271.png" alt="image-20210913154745133"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//可重用锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://qiniu.c77544s.top/picgo/202210121452272.png" alt="image-20210913155517504"></p><p><img src="http://qiniu.c77544s.top/picgo/202210121452273.png" alt="image-20210914100541540"></p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p><img src="http://qiniu.c77544s.top/picgo/202210121452274.png" alt="image-20210913160126353"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合源码分析</title>
      <link href="/2021/08/28/%E5%90%8E%E7%AB%AF/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/28/%E5%90%8E%E7%AB%AF/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HashCode为什么使用31作为乘数"><a href="#HashCode为什么使用31作为乘数" class="headerlink" title="HashCode为什么使用31作为乘数"></a>HashCode为什么使用31作为乘数</h1><ol><li><p>31 是⼀个奇质数，如果选择偶数会导致乘积运算时数据溢出。</p></li><li><p>另外在⼆进制中，2个5次⽅是32，那么也就是 31 * i &#x3D;&#x3D; (i &lt;&lt; 5) - i 。这主要是说乘积运算</p></li></ol><p>可以使⽤位移提升性能，同时⽬前的JVM虚拟机也会⾃动⽀持此类的优化。</p><ol start="3"><li><p>碰撞少，和33、37、39、41比起来乘数是<strong>31</strong>的时候，碰撞的概率已经很⼩了，基本稳定。</p><p><img src="http://qiniu.c77544s.top/picgo/202210121452903.png" alt="image-20210828140827836"></p></li><li><p>顺着往下看，你会发现199的碰撞概率更⼩，这就相当于⼀排奇数的茅坑量多，⾃然会减少碰撞。</p></li></ol><p>但这个范围值已经远超过<strong>int</strong>的取值范围了，如果⽤此数作为乘数，⼜返回<strong>int</strong>值，就会丢失数据信</p><p>息。</p><ol start="5"><li>除199外（不能选），31是Hash值散列分布最均匀的</li></ol><h1 id="HashMap-扰动函数、负载因⼦、扩容链表拆分"><a href="#HashMap-扰动函数、负载因⼦、扩容链表拆分" class="headerlink" title="HashMap 扰动函数、负载因⼦、扩容链表拆分"></a><strong>HashMap</strong> 扰动函数、负载因⼦、扩容链表拆分</h1><p>在Jdk1.8中HashMap是使⽤ <code>桶数组+链表和红⿊树</code> 实现</p><p>HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0</p><p>在JDK 1.8中包括； <code>1、散列表实现</code> 、 <code>2、扰动函数 </code>、<code>3、初始化容量</code> 、<code> 4、负载因⼦</code> 、 <code>5、扩容元素拆分</code> 、 <code>6、链表树化 </code>、 <code>7、红⿊树</code> 、 <code>8、插⼊</code> 、 <code>9、查找</code> 、<code>10、删除</code> 、 <code>11、遍历</code> 、 <code>12、分段锁</code> 等等</p><h2 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>key.hashCode()</code>取值范围是[-2147483648, 2147483647]</p><p>默认初始化的Map⼤⼩是16个⻓度 <code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code> ，所以获取的Hash值</p><p>并不能直接作为下标使⽤，需要与数组⻓度进⾏取模运算得到⼀个下标值，也就是我们上⾯做的散列列</p><p>⼦。</p><p><img src="http://qiniu.c77544s.top/picgo/202210121452905.png" alt="image-20210828143930308"></p><p>说⽩了，使⽤扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞</p><h2 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h2><p>HashMap初始化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"><span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阀值 threshold ，通过⽅法 tableSizeFor 进⾏计算，是根据初始化来计算的。</li><li>这个⽅法也就是要寻找⽐初始值⼤的，最⼩的那个2进制数值。⽐如传了17，我应该找到的是32。</li></ul><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>负载因⼦决定了数据量多少了以后进⾏扩容。默认值0.75就是说当阀值容量占了3&#x2F;4s时赶紧扩容，减少</p><p>Hash碰撞。</p><h2 id="扩容元素拆分"><a href="#扩容元素拆分" class="headerlink" title="扩容元素拆分"></a>扩容元素拆分</h2><p>如上所述，数组长度是2的倍数，每次扩容是：原先的长度*2</p><p>扩容最直接的问题，就是需要把元素拆分到新的数组中。拆分元素的过程中，原jdk1.7中会需要重新计算哈希值，但是到jdk1.8中已经进⾏优化，不在需要重新计算，提升了拆分的性能。</p><p>原哈希值和扩容后的长度进行<code>&amp;</code>运算,如果值等于0，则下标位置不变。如果不为0，那么新的位置则是原来位置上加老的数组长度。</p><p><img src="http://qiniu.c77544s.top/picgo/202210121452906.png" alt="image-20210828150220532"></p><ul><li>这张图就是原16位⻓度数组元素，像32位数组⻓度中转移的过程。</li><li>其中⻩⾊区域元素 <code>zuio</code> 因计算结果 <code>hash &amp; oldCap</code> 不为1，则被迁移到下标位置24。</li><li>同时还是⽤重新计算哈希值的⽅式验证了，确实分配到24的位置，因为这是在⼆进制计算中补1的过程，所以可以通过上⾯简化的⽅式确定哈希值的位置。</li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入流程："><a href="#插入流程：" class="headerlink" title="插入流程："></a>插入流程：</h3><p><img src="http://qiniu.c77544s.top/picgo/202210121452907.png" alt="image-20210828151943345"></p><p>以上就是HashMap中⼀个数据插⼊的整体流程，包括了；计算下标、何时扩容、何时链表转红⿊树等，</p><p>具体如下；</p><ol><li><p>⾸先进⾏哈希值的扰动，获取⼀个新的哈希值。 <code>(key == null) ? 0 : (h =key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>;</p></li><li><p>判断tab是否位空或者⻓度为0，如果是则进⾏扩容操作。</p></li><li><p>根据哈希值计算下标，如果对应⼩标正好没有存放数据，则直接插⼊即可否则需要覆盖。 <code>tab[i =(n - 1) &amp; hash])</code></p></li><li><p>判断tab[i]是否为树节点，否则向链表中插⼊数据，是则向树中插⼊节点。</p></li><li><p>如果链表中插⼊节点的时候，链表⻓度⼤于等于8，则需要把链表转换为红⿊树。<code> treeifyBin(tab, hash)</code>;</p></li><li><p>最后所有元素处理完成后，判断是否超过阈值:<code>threshold</code> ，超过则扩容。</p></li><li><p><code>treeifyBin</code> ,是⼀个链表转树的⽅法，但不是所有的链表⻓度为8后都会转成树，还需要判断存放key值的数组桶⻓度是否⼩于64 <code>MIN_TREEIFY_CAPACITY</code> 。如果⼩于则需要扩容，扩容后链表上的数据会被拆分散列的相应的桶节点上，也就把链表⻓度缩短了。</p></li></ol><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>参考上一小节的扩容元素拆分</p><h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><p>jdk1.8之前的设计只是采⽤链表的⽅式进⾏存放，如果需要从链表中定位到数据时间复杂度就是O(n)，链表越⻓性能越差。因为在jdk1.8中把过⻓的链表也就是<strong>8个</strong>，优化为⾃平衡的红⿊树结构，以此让定位元素的时间复杂度优化近似于O(logn)，这样来提升元素查找的效率。但也不是完全抛弃链表，因为在元素相对不多的情况下，链表的插⼊速度更快，所以综合考虑下设定<strong>阈值为8</strong>才进⾏红⿊树转换操作。</p><p><img src="http://qiniu.c77544s.top/picgo/202210121452908.png" alt="image-20210828153305822"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 这块就是我们上⾯提到的，不⼀定树化还可能只是扩容。主要桶数组容量是否⼩于64 MIN_TREEIFY_CAPACITY</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ⼜是单词缩写；hd = head (头部)，tl = tile (结尾)</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点转换为树节点，但此时还不是红⿊树，也就是说还不⼀定平衡</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 转红⿊树操作，这⾥需要循环⽐较，染⾊、旋转。关于红⿊树，在下⼀章节详细讲解</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上源码主要包括的知识点如下；</p><ol><li>链表树化的条件有两点；链表⻓度⼤于等于8、桶容量⼤于64，否则只是扩容，不会树化。</li><li>链表树化的过程中是先由链表转换为树节点，此时的树可能不是⼀颗平衡树。同时在树转换过程中会记录链表的顺序， <code>tl.next = p</code> ，这主要<strong>⽅便后续树转链表和拆分更⽅便</strong>。</li><li>链表转换成树完成后，在进⾏红⿊树的转换。先简单介绍下，红⿊树的转换需要染⾊和旋转，以及⽐对⼤⼩。在⽐较元素的⼤⼩中，有⼀个⽐较有意思的⽅法， <code>tieBreakOrder</code> 加时赛，这主要是因为HashMap没有像TreeMap那样本身就有Comparator的实现。</li></ol><h3 id="红黑树转链表"><a href="#红黑树转链表" class="headerlink" title="红黑树转链表"></a>红黑树转链表</h3><p>在链表转红⿊树中，记录了原有链表的顺序。那么，这就简单了，红⿊树转链表时候，直接把TreeNode转换为Node即可，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历TreeNode</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// TreeNode替换Node</span></span><br><span class="line">        Node&lt;K, V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换⽅法</span></span><br><span class="line">Node&lt;K, V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K, V&gt; p, Node&lt;K, V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src="http://qiniu.c77544s.top/picgo/202210121452909.png" alt="image-20210828154724482"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>比较简单，不做介绍</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><strong>KeySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">System.out.print(key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EntrySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (HashMap.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.print(entry + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从⽅法上以及⽇常使⽤都知道，KeySet是遍历是⽆序的，但每次使⽤不同⽅式遍历包括 <code>keys.iterator()</code> ，它们遍历的结果是固定的。</p><p><strong>链表和红黑树的遍历如下图所示：</strong></p><p><img src="http://qiniu.c77544s.top/picgo/202210121452910.png"></p><p><img src="http://qiniu.c77544s.top/picgo/202210121452911.png" alt="image-20210828160132910"></p><h1 id="ArrayList数据结构"><a href="#ArrayList数据结构" class="headerlink" title="ArrayList数据结构"></a>ArrayList数据结构</h1><p><code>Array + List = 数组 + 列表 = ArrayList = 数组列表</code></p><p><img src="http://qiniu.c77544s.top/picgo/202210121452912.png" alt="image-20210829120240946"></p><p>ArrayList默认初始化时会申请<strong>10</strong>个⻓度的空间</p><h1 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h1><p>扩容的⻓度计算； <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> ，旧容量 + 旧</p><p>容量右移1位，这相当于扩容了原来容量的 <code>(int)3/2</code> 。</p><p>10，扩容时：1010 + 1010 &gt;&gt; 1 &#x3D; 1010 + 0101 &#x3D; 10 + 5 &#x3D; 15</p><p>7，扩容时：0111 + 0111 &gt;&gt; 1 &#x3D; 0111 + 0011 &#x3D; 7 + 3 &#x3D; 10</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM知识点</title>
      <link href="/2021/08/25/%E5%90%8E%E7%AB%AF/Java/JVM/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/08/25/%E5%90%8E%E7%AB%AF/Java/JVM/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="http://qiniu.c77544s.top/picgo/202210121455833.png" alt="image-20210911130213222"></p><img src="http://qiniu.c77544s.top/picgo/202210121455836.png" alt="image-20210825195314252" style="zoom:50%;" /><p>JVM调优99%都是在调 <strong>方法区</strong> 和 <strong>堆</strong> ，且大部分是堆， 垃圾回收也回收这两个区域</p><p><img src="http://qiniu.c77544s.top/picgo/202210121455837.png" alt="image-20210825215354387"></p><h2 id="Java-类加载机制"><a href="#Java-类加载机制" class="headerlink" title="Java 类加载机制"></a>Java 类加载机制</h2><p><img src="https://img-blog.csdnimg.cn/20200904160557387.png" alt="image.png"></p><ul><li>加载 加载字节码文件。</li><li>链接<ul><li>验证 验证字节码文件的正确性。</li><li>准备 为静态变量分配内存。</li><li>解析 将符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址）。</li></ul></li><li>初始化 为静态变量赋初值。</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>java为了安全会有一个类的加载顺序</p><p><strong>APP –&gt; EXT(ext文件夹下的jar) –&gt; ROOT（rt.jar）（最终执行）</strong></p><p>所以，即使在项目中定义了一个String类，且和rt.jar（rt就是root的缩写） 中的String包明相同，也只会加载 rt.jar中的String</p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><h3 id="组成沙箱的基本组件"><a href="#组成沙箱的基本组件" class="headerlink" title="组成沙箱的基本组件"></a>组成沙箱的基本组件</h3><p>**<code>字节码校验器</code>**：确保Java类文件遵守Java语言规范。也可以帮助Java实现内存保护。但并不是所有的类都会经过字节码校验，比如核心类。（java javax）</p><p><strong>类装载器</strong>：在3个方面对Java沙箱起作用：</p><ul><li>防止恶意代码干涉善意代码  &#x2F;&#x2F;eg 双亲委派机制</li><li>守护了被信任的类库边界 &#x2F;&#x2F;eg 双亲委派机制</li><li>将代码归入保护域，确定了代码可以进行那些操作</li></ul><h2 id="JVM堆内存"><a href="#JVM堆内存" class="headerlink" title="JVM堆内存"></a>JVM堆内存</h2><p><img src="http://qiniu.c77544s.top/picgo/202210121455838.png" alt="image-20210830165415294"></p><p><strong>永久区</strong></p><p>这个区域是常驻内存的。用来存放一些jdk自身存在的Class对象。Interface元数据，存储的是java运行时的一些环境或类信息，这个区域不存在垃圾回收！</p><p>一个启动类加载了太多的第三方jar包、tomcat部署太多应用、大量动态生成的反射类等情况，不断加载，知道内存满，就会出现OOM</p><p>jdk1.6：永久代，常量池在方法区中</p><p>jdk1.7 ：永久代，但是慢慢的退化了，去永久代，常量池在堆中</p><p>jdk1.8后：无永久代，常量池在元空间</p><p><img src="http://qiniu.c77544s.top/picgo/202210121455839.png" alt="image-20210830170324793"></p><h2 id="JVM参数调优"><a href="#JVM参数调优" class="headerlink" title="JVM参数调优"></a>JVM参数调优</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory();</span><br><span class="line">    System.out.println(<span class="string">&quot;max=&quot;</span>+max/(<span class="type">double</span>)<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total=&quot;</span>+total/(<span class="type">double</span>)<span class="number">1024</span>/<span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OOM问题解决:</span></span><br><span class="line">    <span class="comment">//1.尝试扩大堆内存看结果</span></span><br><span class="line">    <span class="comment">//2。分析内存，看哪里出问题</span></span><br><span class="line">    <span class="comment">// 默认情况下：分配的总内存是 电脑内存的1/4，而初始化的内存：1/64 （粗略值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候填入JVM参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><code>-Xms1024m</code> 是指： JVM启动时整个堆(包括年轻代，年老代)的初始化大小。</p><p><code>-Xmx1024m</code> 是指： JVM启动时整个堆的最大值。</p><p><code>-Xmn1024m</code>是指：年轻代的空间大小，剩下的是年老代的空间。</p><p><code>-XX:+PrintGCDetails</code>是指，打印GC的信息</p><p><code>-XX:+HeapDumpOnOutOfMemoryError</code> 是指：打印出OOM的Dump文件</p><p><img src="http://qiniu.c77544s.top/picgo/202210121455840.png" alt="image-20210830173444956"></p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>相关概念：<strong>标记清除法、标记压缩、复制算法</strong>、引用计数器（一般不使用）</p><p><strong>新生代使用：复制算法</strong> （from survivor、to survivor）</p><p><strong>老年代使用：标记清除法+标记压缩法</strong></p><p>一般不使用引用计数器法的实现</p><ul><li><p>Mark-Sweep（标记-清除）算法 标记需要回收的对象，然后清除，会造成许多内存碎片。</p></li><li><p>Copying（复制）算法 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。</p></li><li><p>Mark-Compact（标记-整理）算法（压缩法） 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。</p></li><li><p>Generational Collection（分代收集）算法 分为年轻代和老年代，年轻代时比较活跃的对象，使用复制算法做垃圾回收。老年代每次回收只回收少量对象，使用标记整理法。</p></li></ul><h2 id="典型垃圾回收器"><a href="#典型垃圾回收器" class="headerlink" title="典型垃圾回收器"></a>典型垃圾回收器</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul><li>简介 以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是 Mark-Sweep 算法。</li><li>场景 如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的 CPU 资源也比较丰富，就适合适用 CMS 收集器。</li><li>垃圾回收步骤</li></ul><blockquote><ol><li><p>初始标记 (Stop the World 事件 CPU 停顿， 很短) 初始标记仅标记一下 GC Roots 能直接关联到的对象，速度很快；</p></li><li><p>并发标记 (收集垃圾跟用户线程一起执行) 并发标记过程就是进行 GC Roots 查找的过程；</p></li><li><p>重新标记 (Stop the World 事件 CPU 停顿，比初始标记稍微长，远比并发标记短) 修正由于并发标记时应用运行产生变化的标记。</p></li><li><p>并发清理，标记清除算法；</p></li></ol></blockquote><ul><li>缺点</li></ul><blockquote><ol><li>并发标记时和应用程序同时进行，占用一部分线程，所以吞吐量有所下降。</li><li>并发清除时和应用程序同时进行，这段时间产生的垃圾就要等下一次 GC 再清除。</li><li>采用的标记清除算法，产生内存碎片，如果要新建大对象，会提前触发 Full GC 。</li></ol></blockquote><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ul><li>简介 是一款面向服务端应用的收集器，它能充分利用多 CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型，即可以设置 STW 的时间。</li><li>垃圾回收步骤 1、初始标记(stop the world 事件 CPU 停顿只处理垃圾)； 2、并发标记(与用户线程并发执行)； 3、最终标记(stop the world 事件 ,CPU 停顿处理垃圾)； 4、筛选回收(stop the world 事件 根据用户期望的 GC 停顿时间回收)</li><li>特点<ul><li>并发与并行 充分利用多核 CPU ，使用多核来缩短 STW 时间，部分需要停顿应用线程的操作，仍然可以通过并发保证应用程序的执行。</li><li>分代回收 新生代，幸存带，老年代</li><li>空间整合 总体看是采用标记整理算法回收，每个 Region 大小相等，通过复制来回收。</li><li>可预测的停顿时间 使用 -XX:MaxGCPauseMillis&#x3D;200 设置最长目标暂停值。</li></ul></li></ul><h3 id="可作为-GC-Roots-的对象包括-4-种情况："><a href="#可作为-GC-Roots-的对象包括-4-种情况：" class="headerlink" title="可作为 GC Roots 的对象包括 4 种情况："></a>可作为 GC Roots 的对象包括 4 种情况：</h3><blockquote><p>a) 虚拟机栈中引用的对象（栈帧中的本地变量表）；</p><p> b) 方法区中类静态属性引用的对象；</p><p> c) 方法区中常量引用的对象；</p><p> d) 本地方法栈中 Native 方法引用的对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq笔记</title>
      <link href="/2021/08/23/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Rabbitmq%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/23/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Rabbitmq%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="AMQP简介"><a href="#AMQP简介" class="headerlink" title="AMQP简介"></a>AMQP简介</h1><p>AMQP（高级消息队列协议）是一个网络协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。</p><h2 id="消息代理和他们所扮演的角色"><a href="#消息代理和他们所扮演的角色" class="headerlink" title="消息代理和他们所扮演的角色"></a>消息代理和他们所扮演的角色</h2><p>消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。</p><p>由于AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。</p><h2 id="AMQP-0-9-1-模型简介"><a href="#AMQP-0-9-1-模型简介" class="headerlink" title="AMQP 0-9-1 模型简介"></a>AMQP 0-9-1 模型简介</h2><p>AMQP 0-9-1的工作过程如下图：消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p><p><img src="http://qiniu.c77544s.top/picgo/202210121456833.png" alt="hello-world-example-routing"></p><h2 id="AMQP是一个可编程的协议"><a href="#AMQP是一个可编程的协议" class="headerlink" title="AMQP是一个可编程的协议"></a>AMQP是一个可编程的协议</h2><p>AMQP 0-9-1是一个可编程协议，某种意义上说AMQP的实体和路由规则是由应用本身定义的，而不是由消息代理定义。包括像声明队列和交换机，定义他们之间的绑定，订阅队列等等关于协议本身的操作。</p><p>这虽然能让开发人员自由发挥，但也需要他们注意潜在的定义冲突。当然这在实践中很少会发生，如果发生，会以配置错误（misconfiguration）的形式表现出来。</p><p>应用程序（Applications）声明AMQP实体，定义需要的路由方案，或者删除不再需要的AMQP实体。</p><h2 id="交换机和交换机类型"><a href="#交换机和交换机类型" class="headerlink" title="交换机和交换机类型"></a>交换机和交换机类型</h2><p>交换机是用来发送消息的AMQP实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。AMQP 0-9-1的代理提供了四种交换机</p><table><thead><tr><th>Name（交换机类型）</th><th>Default pre-declared names（预声明的默认名称）</th></tr></thead><tbody><tr><td>Direct exchange（直连交换机）</td><td>(Empty string) and amq.direct</td></tr><tr><td>Fanout exchange（扇型交换机）</td><td>amq.fanout</td></tr><tr><td>Topic exchange（主题交换机）</td><td>amq.topic</td></tr><tr><td>Headers exchange（头交换机）</td><td>amq.match (and amq.headers in RabbitMQ)</td></tr></tbody></table><p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：</p><ul><li>Name</li><li>Durability （消息代理重启后，交换机是否还存在）</li><li>Auto-delete （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）</li><li>Arguments（依赖代理本身）</li></ul><p>交换机可以有两个状态：持久（durable）、暂存（transient）。持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。然而并不是所有的应用场景都需要持久化的交换机。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2021/08/23/%E5%90%8E%E7%AB%AF/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/08/23/%E5%90%8E%E7%AB%AF/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h1><h2 id="多线程实现的原理"><a href="#多线程实现的原理" class="headerlink" title="多线程实现的原理"></a>多线程实现的原理</h2><ul><li>Java语言的JVM允许程序运行多个线程，多线程可以通过Java中的java.lang.Thread类来体现。</li><li>Thread类的特性<ul><li>每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，经常吧run()方法的主体称为线程体。</li><li>通过Thread方法的start()方法来启动这个线程，而非直接调用run()。</li></ul></li></ul><h2 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a>方式一：继承于Thread类</h2><ol><li>创建一个继承于Thread类的子类。</li><li>重写Thread类的run()方法。</li><li>创建Thread类的子类的对象。</li><li>通过此对象调用start()来启动一个线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//线程体,启动线程时会运行run()方法中的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//输出100以内的偶数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Thread类的子类对象</span></span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        <span class="comment">//通过此对象调用start()启动一个线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//注意:已经启动过一次的线程无法再次启动</span></span><br><span class="line">        <span class="comment">//再创建一个线程</span></span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种调用方法,此方法并没有给对象命名</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadTest</span>().start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式一：创建Thread匿名子类（也属于方法一）"><a href="#方式一：创建Thread匿名子类（也属于方法一）" class="headerlink" title="方式一：创建Thread匿名子类（也属于方法一）"></a>方式一：创建Thread匿名子类（也属于方法一）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousSubClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口#"></a>方式二：实现Runnable接口<a href="https://www.cnblogs.com/13roky/p/14707360.html#24-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3">#</a></h2><ol><li>创建一个实现Runnable接口的类。</li><li>实现类去实现Runnable接口中的抽象方法：run()。</li><li>创建实现类的对象。</li><li>将此对象作为参数传到Thread类的构造器中，创建Thread类的对象。</li><li>通过Thread类的对象调用start()方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实现类的对象</span></span><br><span class="line">        <span class="type">RunnableThread01</span> <span class="variable">runnableThread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableThread01</span>();</span><br><span class="line">        <span class="comment">//创建Thread类的对象,并将实现类的对象当做参数传入构造器</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableThread01);</span><br><span class="line">        <span class="comment">//使用Thread类的对象去调用Thread类的start()方法:①启动了线程 ②Thread中的run()调用了Runnable中的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在创建一个线程时，只需要new一个Thread类就可,不需要new实现类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableThread01);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RunnableThread01实现Runnable接口的run()抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableThread01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较创建线程的两种方式"><a href="#比较创建线程的两种方式" class="headerlink" title="比较创建线程的两种方式"></a>比较创建线程的两种方式</h3><ul><li>Java中只允许单进程，以卖票程序TiketSales类来说，很有可能这个类本来就有父类，这样一来就不可以继承Thread类来完成多线程了，但是一个类可以实现多个接口，因此实现的方式没有类的单继承性的局限性，用实现Runnable接口的方式来完成多线程更加实用。</li><li>实现Runnable接口的方式天然具有共享数据的特性（不用static变量）。因为继承Thread的实现方式，需要创建多个子类的对象来进行多线程，如果子类中有变量A，而不使用static约束变量的话，每个子类的对象都会有自己独立的变量A，只有static约束A后，子类的对象才共享变量A。而实现Runnable接口的方式，只需要创建一个实现类的对象，要将这个对象传入Thread类并创建多个Thread类的对象来完成多线程，而这多个Thread类对象实际上就是调用一个实现类对象而已。实现的方式更适合来处理多个线程有共享数据的情况。</li><li>联系：Thread类中也实现了Runnable接口</li><li>相同点两种方式都需要重写run()方法，线程的执行逻辑都在run()方法中</li></ul><h2 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h2><p><strong>与Runnable相比，Callable功能更强大</strong></p><ol><li>相比run()方法，可以有返回值</li><li>方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类，比如获取返回结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中Call方法的返回值</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为&quot;</span>+sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式四：线程池"><a href="#方式四：线程池" class="headerlink" title="方式四：线程池"></a>方式四：线程池</h2><p><strong>背景：</strong></p><p> 经常创建和销毁、使用量特别大的资源、比如并发情况下的线程、对性能影响很大。</p><p><strong>思路：</strong></p><p> 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p><strong>优点：</strong></p><p> 提高响应速度（减少了创建新线程的时间）</p><p> 降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p><p> 便于线程管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line">        <span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line">        <span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line">        <span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象。</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>()); <span class="comment">//适合用于Runnable</span></span><br><span class="line">        <span class="comment">//        service.submit(); 适合适用于Callable</span></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式五：CompletableFuture"><a href="#方式五：CompletableFuture" class="headerlink" title="方式五：CompletableFuture"></a>方式五：CompletableFuture</h2><p>见[[JUC笔记]]</p><h1 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h1><ul><li>start() : 启动当前线程, 调用当前线程的run()方法</li><li>run() : 通常需要重写Thread类中的此方法, 将创建的线程要执行的操作声明在此方法中</li><li>currentThread() : 静态方法, 返回当前代码执行的线程</li><li>getName() : 获取当前线程的名字</li><li>setName() : 设置当前线程的名字</li><li>yield() : 释放当前CPU的执行权</li><li>join() : 在线程a中调用线程b的join(), 此时线程a进入阻塞状态, 知道线程b完全执行完以后, 线程a才结束阻塞状态</li><li>stop() : 已过时. 当执行此方法时,强制结束当前线程.</li><li>sleep(long militime) : 让线程睡眠指定的毫秒数，在指定时间内，线程是阻塞状态</li><li>isAlive() ：判断当前线程是否存活</li></ul><h1 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h1><h2 id="cpu的调度策略"><a href="#cpu的调度策略" class="headerlink" title="cpu的调度策略"></a>cpu的调度策略</h2><ul><li><strong>时间片</strong></li><li><strong>抢占式：</strong>高优先级的线程抢占cpu。</li></ul><h2 id="Java的调度算法："><a href="#Java的调度算法：" class="headerlink" title="Java的调度算法："></a>Java的调度算法：</h2><ul><li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略。</li><li>堆高优先级，使用优先调度的抢占式策略。</li></ul><p><strong>线程的优先级等级</strong>（一共有10挡）</p><ul><li>MAX_PRIORITY：10</li><li>MIN_PRIORITY：1</li><li>NORM_PRIORITY：5 (默认优先级)</li></ul><p><strong>获取和设置当前线程的优先级</strong></p><ul><li><code>getPriority();</code> 获取</li><li><code>setPriority(int p);</code> 设置</li></ul><p><strong>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有高优先级的线程执行完成以后，低优先级的线程才执行。</strong></p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><ul><li>JDk中用Thread.State类定义了线程的几种状态</li></ul><p><img src="https://i.vgy.me/qiV0by.png" alt="线程的声明周期"></p><h1 id="线程同步问题解决"><a href="#线程同步问题解决" class="headerlink" title="线程同步问题解决"></a>线程同步问题解决</h1><h2 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;需要被同步的代码&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>操作共享数据（多个线程共同操作的变量）的代码，即为需要被同步的代码。 不能多包涵代码（效率低，如果包到while前面就变成了单线程了），也不能少包含代码</li><li>共享数据：多个线程共同操作的变量。</li><li>同步监视器：俗称，锁。任何一个类的对象都可以充当锁。但是所有的线程都必须共用一把锁，共用一个对象。</li></ol><p>锁的选择：</p><ol><li><p>自行创建，共用对象，如下面demo中的Object对象。</p></li><li><p>使用this表示当前类的对象</p><p>继承Thread的方法中的锁不能使用this代替，因为继承thread实现多线程时，会创建多个子类对象来代表多个线程，这个时候this指的时当前这个类的多个对象，不唯一，无法当作锁。</p><p>实现Runnable接口的方式中，this可以当作锁，因为这种方式只需要创建一个实现类的对象，将实现类的对象传递给多个Thread类对象来当作多个线程，this就是这个一个实现类的对象，是唯一的，被所有线程所共用的对象。</p></li><li><p>使用类当作锁，以下面demo为例，其中的锁可以写为<code>WindowThread.class</code>, 从这里可以得出结论，类也是一个对象</p></li></ol><p>优点：同步的方式，解决了线程安全的问题</p><p>缺点：操作同步代码时，只能有一个线程参与，其他线程等待。相当于时一个单线程的过程，效率低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tiketsNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于，Runnable实现多线程，所有线程共用一个实现类的对象，所以三个线程都共用实现类中的这个Object类的对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">//如果时继承Thread类实现多线程，那么需要使用到static Object obj = new Object();</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Object obj = new Object();</span></span><br><span class="line">        <span class="comment">//如果Object对象在run()方法中创建，那么每个线程运行都会生成自己的Object类的对象，并不是三个线程的共享对象，所以并没有给加上锁。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tiketsNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//手动让线程进入阻塞,增大安全性发生的概率</span></span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h2><p>将所要同步的代码放到一个方法中，将方法声明为synchronized同步方法。之后可以在run()方法中调用同步方法。</p><p><strong>要点：</strong></p><ol><li>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。</li><li>非静态的同步方法，同步监视器是：this。</li><li>静态的同步方法，同步监视器是：当前类本身。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window02Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tiketsNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (tiketsNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">//同步监视器：this</span></span><br><span class="line">        <span class="keyword">if</span> (tiketsNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//手动让线程进入阻塞,增大安全性发生的概率</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;<span class="comment">//同步监视器：Winddoe03Thread.class  不加static话同步监视器为t1 t2 t3所以错误</span></span><br><span class="line">        <span class="keyword">if</span> (tiketsNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//手动让线程进入阻塞,增大安全性发生的概率</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用同步解决懒汉模式的线程安全问题"><a href="#使用同步解决懒汉模式的线程安全问题" class="headerlink" title="使用同步解决懒汉模式的线程安全问题"></a>使用同步解决懒汉模式的线程安全问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方式一：效率性差，每个等待线程都会进入同步代码块</span></span><br><span class="line">        <span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line">        <span class="comment">//            if (instance == null) &#123;</span></span><br><span class="line">        <span class="comment">//                instance = new Bank();</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：在同步代码块外层在判断一次，就防止所有线程进入同步代码块。</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式三：Lock锁-JDK5-0新特性"><a href="#方式三：Lock锁-JDK5-0新特性" class="headerlink" title="方式三：Lock锁 -JDK5.0新特性#"></a>方式三：Lock锁 -JDK5.0新特性<a href="https://www.cnblogs.com/13roky/p/14707360.html#623-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Alock%E9%94%81--jdk50%E6%96%B0%E7%89%B9%E6%80%A7">#</a></h2><p>JDK5.0之后，可以通过实例化ReentrantLock对象，在所需要同步的语句前，调用ReentrantLock对象的lock()方法，实现同步锁，在同步语句结束时，调用unlock()方法结束同步锁</p><p><strong>synchronized和lock的异同：(面试题)</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> Lcok是显式锁（需要手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放。</span><br><span class="line"><span class="bullet">2.</span> Lock只有代码块锁，synchronized有代码块锁和方法锁。</span><br><span class="line"><span class="bullet">3.</span> 使用Lcok锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的拓展性（提供更多的子类）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeLockThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在这里锁住，有点类似同步监视器</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t票号:&quot;</span> + tickets + <span class="string">&quot;\t剩余票数:&quot;</span> + --tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//操作完成共享数据后在这里解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h1><p><strong>所用的到方法：</strong></p><p> wait()：一旦执行此方法，当前线程就会进入阻塞，一旦执行wait()会释放同步监视器。</p><p> notify()：一旦执行此方法，将会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先度最高的。</p><p> notifyAll() ：一旦执行此方法，就会唤醒所有被wait的线程</p><p><strong>说明：</strong></p><p> 这三个方法必须在同步代码块或同步方法中使用。</p><p> 三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p><p> 这三个方法并不时定义在Thread类中的，而是定义在Object类当中的。因为所有的对象都可以作为同步监视器，而这三个方法需要由同步监视器调用，所以任何一个类都要满足，那么只能写在Object类中。</p><p><strong>sleep()和wait()的异同：(面试题)</strong></p><ol><li><p>相同点：两个方法一旦执行，都可以让线程进入阻塞状态。</p></li><li><p>不同点：1) 两个方法声明的位置不同：Thread类中声明sleep(),Object类中声明wait()</p><ol start="2"><li><p>调用要求不同：sleep()可以在任何需要的场景下调用。wait()必须在同步代码块中调用。</p></li><li><p>关于是否释放同步监视器：如果两个方法都使用在同步代码块呵呵同步方法中，sleep不会释放锁，wait会释放锁。</p></li></ol></li></ol><p>[参考来源](<a href="https://www.cnblogs.com/13roky/p/14707360.html">Java多线程详解——一篇文章搞懂Java多线程 - 13roky - 博客园 (cnblogs.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud笔记</title>
      <link href="/2021/08/04/%E5%90%8E%E7%AB%AF/Spring%20Cloud/Spring-Cloud%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/04/%E5%90%8E%E7%AB%AF/Spring%20Cloud/Spring-Cloud%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloud-模块的相关介绍如下："><a href="#Spring-Cloud-模块的相关介绍如下：" class="headerlink" title="Spring Cloud 模块的相关介绍如下："></a>Spring Cloud 模块的相关介绍如下：</h2><ol><li>Eureka：服务注册中心，用于服务管理。</li><li>Ribbon：基于客户端的负载均衡组件。</li><li>Hystrix：容错框架，能够防止服务的雪崩效应。</li><li>Feign：Web 服务客户端，能够简化 HTTP 接口的调用。</li><li>Zuul：API 网关，提供路由转发、请求过滤等功能。</li><li>Config：分布式配置管理。</li><li>Sleuth：服务跟踪。</li><li>Stream：构建消息驱动的微服务应用程序的框架。</li><li>Bus：消息代理的集群消息总线。</li></ol><p>除了上述模块，还有 Cli、Task等。这里只记几种常用的</p><p><strong>SpringCloud的基础功能：</strong></p><ul><li><p>服务治理：     Spring Cloud Eureka</p></li><li><p>客户端负载均衡：     Spring Cloud Ribbon</p></li><li><p>服务容错保护：     Spring Cloud Hystrix</p></li><li><ul><li>断路器（熔断）（在服务端）、服务降级（在客户端）、线程隔离</li><li>仪表盘（Hystrix Dashboard）：实时监控，引入Turbine（监控端点）汇集监控信息</li></ul></li><li><p>声明式服务调用：     Spring Cloud Feign</p></li><li><ul><li>整合了 Ribbon 与 Hystrix, 除此之外，它还提 供了声明式的服务调用(不再通过RestTemplate)。</li><li>Feign是一种声明式、模板化的HTTP客户端。在Spring      Cloud中使用Feign,      我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</li></ul></li><li><p>API网关服务：Spring     Cloud Zuul</p></li><li><ul><li>提供：代理+路由+过滤 三大功能</li><li>比如购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在购物车和订单模块都编写校验逻辑，这无疑是冗余的代码。</li><li>通过Spring Cloud Zuul使得多有的外层调用必须通过API网关</li><li>Zuul也是支持Hystrix和Ribbon。但是Zuul路由的是controller请求，而Ribbonhe和Fegin路由了service的请求</li></ul></li><li><p>分布式配置中心：     Spring Cloud Config</p></li><li><ul><li>使用Spring      Cloud Config就是将配置文件放到统一的位置管理(比如GitHub)，客户端通过接口去获取这些配置文件。</li></ul></li></ul><p><strong>SpringCloud的高级功能：</strong></p><ul><li>消息总线：     Spring Cloud Bus</li><li>消息驱动的微服务：     Spring Cloud Stream</li><li>分布式服务跟踪： Spring Cloud Sleuth</li></ul><h1 id="SpringCloud-和-Dubbo的区别"><a href="#SpringCloud-和-Dubbo的区别" class="headerlink" title="SpringCloud 和 Dubbo的区别"></a>SpringCloud 和 Dubbo的区别</h1><table><thead><tr><th align="center">功能名称</th><th align="center">Dubbo</th><th align="center">Spring Cloud</th></tr></thead><tbody><tr><td align="center">服务注册中心</td><td align="center">ZooKeeper</td><td align="center">Spring Cloud Netflix Eureka</td></tr><tr><td align="center">服务调用方式</td><td align="center">RPC</td><td align="center">REST API</td></tr><tr><td align="center">服务网关</td><td align="center">无</td><td align="center">Spring Cloud Netflix Zuul</td></tr><tr><td align="center">断路器</td><td align="center">不完善</td><td align="center">Spring Cloud Netflix Hystrix</td></tr><tr><td align="center">分布式配置</td><td align="center">无</td><td align="center">Spring Cloud Config</td></tr><tr><td align="center">服务跟踪</td><td align="center">无</td><td align="center">Spring Cloud Sleuth</td></tr><tr><td align="center">消息总线</td><td align="center">无</td><td align="center">Spring Cloud Bus</td></tr><tr><td align="center">数据流</td><td align="center">无</td><td align="center">Spring Cloud Stream</td></tr></tbody></table><h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><p>在分布式系统领域有个著名的 CAP 定理，即 C 为数据一致性；A 为服务可用性；P 为服务对网络分区故障的容错性。这三个特性在任何分布式系统中都不能同时满足，最多同时满足两个。</p><p>为什么 Eureka 比 Zookeeper 更适合作为注册中心呢？主要是因为 Eureka 是基于 AP 原则构建的，而 ZooKeeper 是基于 CP 原则构建的。</p><p>Zookeeper 有一个 Leader，而且在这个 Leader 无法使用的时候通过 Paxos（ZAB）算法选举出一个新的 Leader。这个 Leader 的任务就是保证写数据的时候只向这个 Leader 写入，Leader 会同步信息到其他节点。通过这个操作就可以保证数据的一致性。</p><p>总而言之，想要保证 AP 就要用 Eureka，想要保证 CP 就要用 Zookeeper。</p><p><strong>CAP****理论</strong></p><ul><li><p>C：数据一致性(consistency)</p></li><li><ul><li>所有节点拥有数据的最新版本</li></ul></li><li><p>A：可用性(availability)</p></li><li><ul><li>数据具备高可用性</li></ul></li><li><p>P：分区容错性(partition-tolerance)</p></li><li><ul><li>容忍网络出现分区，分区之间网络不可达。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot自动配置原理</title>
      <link href="/2021/07/31/%E5%90%8E%E7%AB%AF/Spring%20Boot/Spring-Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2021/07/31/%E5%90%8E%E7%AB%AF/Spring%20Boot/Spring-Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>我们知道，Spring Boot 项目创建完成后，即使不进行任何的配置，也能够顺利地运行，这都要归功于 Spring Boot 的自动化配置。</p><p>Spring Boot 默认使用 application.properties 或 application.yml 作为其全局配置文件，我们可以在该配置文件中对各种自动配置属性（server.port、logging.level.* 、spring.config.active.no-profile 等等）进行修改，并使之生效，那么您有没有想过这些属性是否有据可依呢？答案是肯定的。</p><p>Spring Boot 官方文档：常见应用属性中对所有的配置属性都进行了列举和解释，我们可以根据官方文档对 Spring Boot 进行配置，但 Spring Boot 中的配置属性数量庞大，仅仅依靠官方文档进行配置也十分麻烦。我们只有了解了 Spring Boot 自动配置的原理，才能更加轻松熟练地对 Spirng Boot 进行配置。本节为你揭开 SpringBoot 自动配置的神秘面纱。</p><h1 id="Spring-Factories机制"><a href="#Spring-Factories机制" class="headerlink" title="Spring Factories机制"></a>Spring Factories机制</h1><p>Spring Boot 的自动配置是基于 Spring Factories 机制实现的。</p><p>Spring Factories 机制是 Spring Boot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。Spring Boot 会自动扫描所有 Jar 包类路径下 META-INF&#x2F;spring.factories 文件，并读取其中的内容，进行实例化，这种机制也是 Spring Boot Starter 的基础。</p><h1 id="SpringApplication这个类主要做了以下几件事情"><a href="#SpringApplication这个类主要做了以下几件事情" class="headerlink" title="SpringApplication这个类主要做了以下几件事情"></a>SpringApplication这个类主要做了以下几件事情</h1><ol><li>推断应用是普通项目还是web项目</li><li>查找并加载初始化器，设置到initializers中</li><li>找到所有的应用程序监听器，设置到listers中</li><li>推断并设置main方法的定义类，找到运行的主类</li></ol><h1 id="Spring-Boot的配置文件"><a href="#Spring-Boot的配置文件" class="headerlink" title="Spring Boot的配置文件"></a>Spring Boot的配置文件</h1><p>初识Spring Boot时我们就知道，Spring Boot有一个全局配置文件：application.properties或application.yml。</p><p>我们的各种属性都可以在这个文件中进行配置，最常配置的比如：server.port、logging.level.* 等等，然而我们实际用到的往往只是很少的一部分，那么这些属性是否有据可依呢？答案当然是肯定的，这些属性都可以在官方文档中查找到：</p><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties">https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties</a></p><h1 id="工作原理剖析"><a href="#工作原理剖析" class="headerlink" title="工作原理剖析"></a>工作原理剖析</h1><p>Spring Boot的启动类上有一个@SpringBootApplication注解，这个注解是Spring Boot项目必不可少的注解。那么自动配置原理一定和这个注解有着千丝万缕的联系！</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p> @SpringBootApplication是一个复合注解或派生注解，在@SpringBootApplication中有一个注解@EnableAutoConfiguration，翻译成人话就是开启自动配置，其定义如下：</p><p><img src="http://qiniu.c77544s.top/picgo/202210121456386.png" alt="image-20210907163302698"></p><p>@EnableAutoConfiguration这个注解也是一个派生注解，其中的关键功能由@Import提供，其导入的AutoConfigurationImportSelector的<code>selectImports()</code>方法通过<code>SpringFactoriesLoader.loadFactoryNames()</code>扫描所有具有META-INF&#x2F;spring.factories的jar包。spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。</p><p>这个spring.factories文件也是一组一组的key&#x3D;value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔，如下图所示：</p><p><img src="http://qiniu.c77544s.top/picgo/202210121456387.png" alt="image-20210907163615424"></p><p>这个@EnableAutoConfiguration注解通过@SpringBootApplication被间接的标记在了Spring Boot的启动类上。在SpringApplication.run(…)的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中。</p><h1 id="自动配置生效"><a href="#自动配置生效" class="headerlink" title="自动配置生效"></a>自动配置生效</h1><p>每一个XxxxAutoConfiguration自动配置类都是在某些条件之下才会生效的，这些条件的限制在Spring Boot中以注解的形式体现，常见的条件注解有如下几项：</p><blockquote><p>@ConditionalOnBean：当容器里有指定的bean的条件下。</p><p>@ConditionalOnMissingBean：当容器里不存在指定bean的条件下。</p><p>@ConditionalOnClass：当类路径下有指定类的条件下。</p><p>@ConditionalOnMissingClass：当类路径下不存在指定类的条件下。</p><p>@ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix&#x3D;”xxx.xxx”, value&#x3D;”enable”, matchIfMissing&#x3D;true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。</p></blockquote><p><a href="http://c.biancheng.net/spring_boot/auto-config.html">具体内容点击我</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp实现内网穿透</title>
      <link href="/2021/07/27/%E6%9D%82%E9%A1%B9/frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2021/07/27/%E6%9D%82%E9%A1%B9/frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作中遇到项目中需要开发公众号的情况，公众号平台需要指定域名，且要求端口需要是80或443端口才行。而公司的公网域名和端口已经被使用，为了方便开发调试，使用了frp来实现内网穿透。这里使用的frp版本为<code>0.35.1</code></p><h1 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h1><h2 id="frp是什么"><a href="#frp是什么" class="headerlink" title="frp是什么"></a>frp是什么</h2><p>frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。</p><h2 id="frp-的作用"><a href="#frp-的作用" class="headerlink" title="frp 的作用"></a>frp 的作用</h2><ul><li>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</li><li>对于 http 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li><li>利用处于内网或防火墙后的机器，对外网环境提供 tcp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</li><li>可查看通过代理的所有 http 请求和响应的详细信息。（待开发）</li></ul><h2 id="frp的架构"><a href="#frp的架构" class="headerlink" title="frp的架构"></a>frp的架构</h2><p><img src="https://img-blog.csdnimg.cn/20210205154405707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE3NzMwMg==,size_16,color_FFFFFF,t_70" alt="frp的架构"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p><strong>有公网ip的设备（云服务器，VPS都可以）</strong></p></li><li><p><strong>保证公网设备响应的端口要对外开启，如果是云服务器则到响应的云服务器产商的控制台中开启，以供后续使用</strong></p></li><li><p><strong>如果有使用域名的需求的话，记得将域名映射到公网ip</strong></p></li></ol><h2 id="frp下载地址"><a href="#frp下载地址" class="headerlink" title="frp下载地址"></a>frp下载地址</h2><p>github页面地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a><br><img src="https://img-blog.csdnimg.cn/20210205142940274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE3NzMwMg==,size_16,color_FFFFFF,t_70" alt="frp下载"><br>跟据自己的机器下载对应的版本就好~不然不兼容版本无法运行！！<br>我下载的是：<br>linux服务器：<a href="https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_amd64.tar.gz">frp_0.35.1_linux_amd64.tar.gz</a><br>windows内网机器：<a href="https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_windows_amd64.zip">frp_0.35.1_windows_amd64.zip</a></p><p>如果是32位系统就选386结尾的！</p><h2 id="frp的文件结构"><a href="#frp的文件结构" class="headerlink" title="frp的文件结构"></a>frp的文件结构</h2><p>以windows版本为例<br><img src="https://img-blog.csdnimg.cn/20210205144552881.png" alt="frp文件结构"><br>可以看出，frp中包含了frpc和frps，c即client客户端，s即server服务端。</p><p>frpc.ini、frps.ini 分别是客户端的配置文件和服务端的配置文件，修改配置也是在这里修改</p><p>一般情况下公网机器上只用运行frps，内网机器只用运行frpc</p><h1 id="frp配置与使用"><a href="#frp配置与使用" class="headerlink" title="frp配置与使用"></a>frp配置与使用</h1><h2 id="linux公网服务器的配置-windows配置同理，这里不做说明"><a href="#linux公网服务器的配置-windows配置同理，这里不做说明" class="headerlink" title="linux公网服务器的配置(windows配置同理，这里不做说明)"></a>linux公网服务器的配置(windows配置同理，这里不做说明)</h2><p>1、下载frp文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>2、下载完后解压压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf frp_0.35.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>3、根据需求修改配置（见下文）</p><p>4、启动frps</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> frp_0.35.1_linux_amd64/ </span><br><span class="line">$ ./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><h2 id="通过-ssh-访问公司内网机器"><a href="#通过-ssh-访问公司内网机器" class="headerlink" title="通过 ssh 访问公司内网机器"></a>通过 ssh 访问公司内网机器</h2><p><strong>1、 服务器端：修改 frps.ini 文件，配置一个名为 ssh 的反向代理：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000 <span class="comment">#该端口用于与内网通信</span></span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">listen_port = 6000 <span class="comment">#该端口用于监听ssh请求</span></span><br><span class="line">auth_token = 123</span><br></pre></td></tr></table></figure><p><strong>2、 服务器端：启动 frps：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p><strong>3、 客户端：修改 frpc.ini 文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x <span class="comment">#frps 所在服务器的 IP</span></span><br><span class="line">server_port = 7000 <span class="comment">#frps 配置中bind_port的端口，两者要一直，不然怎么通信</span></span><br><span class="line">auth_token = 123</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">local_port = 22 <span class="comment">#本地ssh监听的端口</span></span><br></pre></td></tr></table></figure><p><strong>4、客户端：启动 frpc：</strong></p><p>1）linux系统的启动方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><p>2）windows系统需要cmd启动frpc.exe：<br><img src="https://img-blog.csdnimg.cn/20210205151509674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE3NzMwMg==,size_16,color_FFFFFF,t_70" alt="windows启动frpc.exe"></p><p><strong>5、 通过 ssh 访问内网机器，假设用户名为 test：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=6000 <span class="built_in">test</span>@x.x.x.x</span><br></pre></td></tr></table></figure><h2 id="通过IP或指定域名访问部署于内网的-web-服务"><a href="#通过IP或指定域名访问部署于内网的-web-服务" class="headerlink" title="通过IP或指定域名访问部署于内网的 web 服务"></a>通过IP或指定域名访问部署于内网的 web 服务</h2><p>有时想要让其他人通过域名访问或者测试我们在本地搭建的 web 服务，但是由于本地机器没有公网 IP，无法将域名解析到本地的机器，通过 frp 就可以实现这一功能，以下示例为 http 服务，https 服务配置方法相同， vhost_http_port 替换为 vhost_https_port， type 设置为 https 即可。</p><p><strong>1、 修改 frps.ini 文件，配置一个名为 web 的 http 反向代理，设置 http 访问端口为 80，绑定IP或域名：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line">[common] </span><br><span class="line">bind_port = 7000 <span class="comment">#该端口用于与内网通信</span></span><br><span class="line">vhost_http_port = 80 <span class="comment">#公网访问的端口，如果是https，这里替换为vhost_https_port</span></span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line"><span class="built_in">type</span> = http <span class="comment">#如果是https，这里替换为https</span></span><br><span class="line">custom_domains = www.yourdomain.com <span class="comment">#这里是你的公网服务器IP或域名</span></span><br><span class="line">auth_token = 123</span><br></pre></td></tr></table></figure><blockquote><p>上述的 [web] 下的配置可以不要</p></blockquote><p><strong>2、 服务器端：启动 frps：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p><strong>3、 客户端：修改 frpc.ini 文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x <span class="comment">#frps 所在服务器的 IP</span></span><br><span class="line">server_port = 7000 <span class="comment">#frps 配置中bind_port的端口，两者要一直，不然怎么通信</span></span><br><span class="line">auth_token = 123</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line"><span class="built_in">type</span> = http <span class="comment">#如果是https，这里替换为https</span></span><br><span class="line">local_port = 8080 <span class="comment">#内网环境web服务的端口</span></span><br><span class="line">custom_domains = www.yourdomain.com <span class="comment">#这里是你的公网服务器IP或域名，如果需要IP或域名同时可以访问，将IP和域名使用逗号分隔写到这里！！！！！！！！！！！</span></span><br></pre></td></tr></table></figure><p><strong>4、客户端：启动 frpc：</strong></p><p>1）linux系统的启动方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><p>2）windows系统需要cmd启动frpc.exe：<br><img src="https://img-blog.csdnimg.cn/20210205151509674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE3NzMwMg==,size_16,color_FFFFFF,t_70" alt="windows启动frpc.exe"></p><p><strong>5、通过浏览器访问 <a href="http://www.yourdomain.com/">http://www.yourdomain.com</a></strong>(没有配域名这边就写ip地址)<strong>:端口</strong>(frps中vhost_http_port的值) <strong>即可访问到处于内网机器上的 web 服务。</strong></p><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><p>DNS、提供文件服务等更多功能，可以参考<a href="https://gitee.com/wefeng/frp">https://gitee.com/wefeng/frp</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>frp是一款方便、快捷、高效的内网穿透工具，但是需要有公网IP的机器，而且访问速度同时受限于内网所处网络和公网机器网络的速度，不过平常使用已经是很不错的选择了。frp还有其他妙用，这里就不再赘述。</p><p>如果有帮到你，那就点赞支持下吧，或者有什么问题，还请留言或者私信~</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
