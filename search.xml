<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试笔记</title>
      <link href="/2023/05/13/%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/13/%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="极兔速递"><a href="#极兔速递" class="headerlink" title="极兔速递"></a>极兔速递</h2><ul><li><input checked="" disabled="" type="checkbox"> configuration 和 component 区别</li><li><input checked="" disabled="" type="checkbox"> 怎么保证接口参数安全？除了加密之外？</li><li><input disabled="" type="checkbox"> rabbitmq 和 kafka 区别</li><li><input checked="" disabled="" type="checkbox"> 多线程怎么保证并发问题，redis 锁存在哪些问题</li><li><input disabled="" type="checkbox"> 项目中的数据库连接密码加密无用操作</li><li><input checked="" disabled="" type="checkbox"> 分布式怎么保证事物的</li><li><input disabled="" type="checkbox"> 下游服务出问题，上游服务怎么感知到</li><li><input disabled="" type="checkbox"> 如何判断一个文件没有被篡改，文件前面 4 个字节判断文件格式，其他呢？</li></ul><h2 id="小牛互娱"><a href="#小牛互娱" class="headerlink" title="小牛互娱"></a>小牛互娱</h2><ul><li><input disabled="" type="checkbox"> JVM gc 算法的底层原理，卡表？染色？</li><li><input disabled="" type="checkbox"> 项目中做过哪些有技术含量的内容，怎么做的</li><li><input disabled="" type="checkbox"> 项目之前的 qps 多少？</li><li><input disabled="" type="checkbox"> 参加项目架构设计，怎么设计的？</li><li><input checked="" disabled="" type="checkbox"> Mysql 索引很慢怎么处理？</li><li><input disabled="" type="checkbox"> Mysql 索引怎么设计的？B+树存在什么问题，比如在插入的时候。</li><li><input checked="" disabled="" type="checkbox"> Es 的倒排索引是怎么设计的</li><li><input disabled="" type="checkbox"> Jvm 内存模型，线程栈？</li><li><input checked="" disabled="" type="checkbox"> Mvcc 乐观锁，undolog readview</li><li><input disabled="" type="checkbox"> Docker 启动时，有哪些方式设置 jvm 堆大小<ul><li>docker run 方法 <code>-e</code> 参数设置</li><li>dockerfile 中 <code>java -jar</code> 命令后设置</li></ul></li><li><input checked="" disabled="" type="checkbox"> Redis 用过哪些数据结构</li><li><input checked="" disabled="" type="checkbox"> Java 流里边，串行流和并行流区别，并行流是怎么实现的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/05/13/%E5%90%8E%E7%AB%AF/Java/JVM/JVM/"/>
      <url>/2023/05/13/%E5%90%8E%E7%AB%AF/Java/JVM/JVM/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，<strong>最大堆内存占用物理内存的1&#x2F;4</strong>，如果应用程序超过该上限，则会抛出 OutOfMemoryError 异常。<strong>初始堆内存大小为物理内存的1&#x2F;64</strong>，但当初始堆内存最小为8MB，则为8MB。</p><h2 id="为什么要分新生代和老年代"><a href="#为什么要分新生代和老年代" class="headerlink" title="为什么要分新生代和老年代"></a>为什么要分新生代和老年代</h2><p>Minor GC——新生代 GC<br>Major GC——老年代GC</p><ol><li>绝大多数对象都是朝生夕灭的，用小范围但高频的 minor gc 去处理这些对象</li><li>熬过越多次垃圾收集过程的对象就越难以销往，低频</li><li>跨代引用相对于同代引用来说仅仅占少数<ol><li>正是因为只占少数，所以不应该为了为了这些少量的跨代引用而区扫描整个老年代，也不能浪费空间让每个对象都记录它是否存在跨代引用，所以为了解决这个问题只需要在新生代建立一个全局的数据结构叫做：记忆集（ Remembered Set ），这个结构把老年代划分成若干小块，并标识哪块内存存在跨代引用，后续新生代发生 gc 时，只有包含了跨代引用的小内存区域才会被加入到 GC Roots 进行扫描</li></ol></li></ol><h2 id="GC-线程如何与用户线程并行"><a href="#GC-线程如何与用户线程并行" class="headerlink" title="GC 线程如何与用户线程并行"></a>GC 线程如何与用户线程并行</h2><p><img src="http://qiniu.c77544s.top/picgo/202305151403370.png" alt="image.png"></p><p>CMS</p><ul><li><p>初始标记</p><ul><li>寻找所有的 GC Root 直接关连的对象，需要 STW，不过这步停顿时间很短</li></ul></li><li><p>并发标记</p><ul><li>三色标记法：下图中，白色代表还没经过标记，灰色是正在标记，黑色是标记过。如果一轮标记完之后还是白色的，代表是垃圾。 </li><li>这个过程中会出现下述问题：<ul><li>浮动垃圾：比如正在标记 C，这时 B 被释放了，结果 C 被成功标记</li><li>对象消失：扫描过 A 之后，A 又引用别的对象，这个对象可能标记不到而被认为是垃圾</li></ul></li><li><img src="http://qiniu.c77544s.top/picgo/202305151420733.png" alt="image.png"></li></ul></li><li><p>重新标记</p><ul><li>为了解决并发标记中存在的问题</li><li>需要STW</li><li><img src="http://qiniu.c77544s.top/picgo/202305151428953.png" alt="image.png"></li></ul></li><li><p>并发删除</p></li></ul><p><img src="http://qiniu.c77544s.top/picgo/202305151433687.png" alt="image.png"></p><p>GC-root 是如何枚举的？<br> hotspot 引入了 <strong>普通对象指针（Ordinary Object Pointer）</strong> 的概念，</p><p>GC 是如何处理跨代引用的？<br>跨代引用假说：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的<br><a href="https://blog.csdn.net/m0_46690280/article/details/121941158">(4条消息) 面试篇之JVM（GC 可达性分析 回收算法 卡表 G1）_g1 卡表实现_Ybb_studyRecord的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka笔记</title>
      <link href="/2023/05/12/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/12/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Kafka 的优点：</p><ol><li>吞吐量高，性能好</li><li>伸缩性好，支持在线水平扩展</li><li>容错性和可靠性</li><li>与大数据生态紧密结合，可无缝对接 haddop、strom、spark 等</li></ol><h2 id="现有的消息模型"><a href="#现有的消息模型" class="headerlink" title="现有的消息模型"></a>现有的消息模型</h2><h3 id="JMS-规范"><a href="#JMS-规范" class="headerlink" title="JMS 规范"></a>JMS 规范</h3><p>Java 中的规范，最常见的就是 Apache ActiveMQ</p><h3 id="AMQP-模型"><a href="#AMQP-模型" class="headerlink" title="AMQP 模型"></a>AMQP 模型</h3><ul><li>队列（queues）</li><li>信箱（exchanges）</li><li>绑定（bingdings）<br>特点：支持事务、数据一致性高，多用于银行、金融行业<br>常见的实现： RabbitMQ</li></ul><h3 id="MQTT-模型"><a href="#MQTT-模型" class="headerlink" title="MQTT 模型"></a>MQTT 模型</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）<br>MQTT 是一种基于客户端服务端架构的发布&#x2F;订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>Topic 主题<ul><li>类似于数据库中的表，属于半结构化</li></ul></li><li>Partition 分区<ul><li>topic 可拆分成多个分区，不同分区放在不同服务器上，使得 Kafka 扩展性很好 </li><li>分区是一个线性增长的不可变的提交日志，分区中的每个消息都有一个偏移量 offset，同一个分区的 offset 递增不可重复，不同分区之间可以重复</li><li>分区副本机制<ul><li>replication-factor&#x3D;xxx，设置副本数量</li><li><img src="http://qiniu.c77544s.top/picgo/202305121146082.png" alt="image.png"></li></ul></li></ul></li><li>Record 消息记录<ul><li>Key—Value</li><li>不指定 key，key 为空，key 为空的消息会轮训写入不同分区</li><li>key 不为空时，相同的 key 会写入相同分区，保证了相同 key 的消息顺序写入</li></ul></li><li>Broker 消息代理<ul><li>Kafka 集群由多个 Broker 组成，通常一个服务器为一个Broker</li><li><img src="http://qiniu.c77544s.top/picgo/202305121152474.png" alt="image.png"></li></ul></li></ul><h2 id="Kafka-消息模型"><a href="#Kafka-消息模型" class="headerlink" title="Kafka 消息模型"></a>Kafka 消息模型</h2><ul><li>分区是最小的并行单位</li><li>一个消费者可消费多个分区</li><li>一个分区可被多个消费者组里的消费者消费</li><li>但是，一个分区不能同时被同一个消费者组里的多个消费者消费<br><img src="http://qiniu.c77544s.top/picgo/202305121220804.png" alt="image.png"></li></ul><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><ul><li>每个消费者都属于不同的消费者组<br><img src="http://qiniu.c77544s.top/picgo/202305121224553.png" alt="image.png"></li></ul><h3 id="点对点（一对一）"><a href="#点对点（一对一）" class="headerlink" title="点对点（一对一）"></a>点对点（一对一）</h3><ul><li>所有消费者都属于同一个消费者组</li><li>该模式也可以实现负载均衡，比如下图如果又加入了 <code>Consumer-4</code> 那么可将 <code>P3</code> 转交给 <code>Consumer-4</code> 处理<br><img src="http://qiniu.c77544s.top/picgo/202305121226271.png" alt="image.png"></li></ul><h3 id="分区与消息顺序"><a href="#分区与消息顺序" class="headerlink" title="分区与消息顺序"></a>分区与消息顺序</h3><ul><li><p>同一个生产者发送到同一分区的消息，先发送的 offset 比后发送的 offset 小</p></li><li><p>同一个生产者发送到不同分区的消息，消息顺序无法保证</p></li><li><p>消费者按照消息在分区里的存放顺序进行消费的</p></li><li><p>Kafka, 只保证分区内的消息顺序，不能保证分区间的消息顺序</p></li></ul><p><strong>如何保证消息全部有序？</strong></p><ol><li>设置一个分区，这样就可以保证所有消息的顺序，但是失去了拓展性和性能</li><li>通常是通过设置消息的 key, 相同 key 的消息会发送的同一个分区</li></ol><h3 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h3><p>需要生产者消费者共同来保证</p><h4 id="最多一次"><a href="#最多一次" class="headerlink" title="最多一次"></a>最多一次</h4><p>消息可能会丢失，永远不重复发送</p><h4 id="最少一次"><a href="#最少一次" class="headerlink" title="最少一次"></a>最少一次</h4><p>消息不会丢失，但是可能会重复</p><h4 id="精确一次"><a href="#精确一次" class="headerlink" title="精确一次"></a>精确一次</h4><p>保证消息被传递到服务端且在服务端不重复<br><strong>生产者实现精确一次</strong>需要实现幂等参数：<code>enable.idempotence=true  acts=all</code><br><strong>消费者实现精确一次</strong></p><ul><li>通过 offset 来防止重复消费不是一个好的办法</li><li>通常在消息中加入<strong>唯一 ID</strong> (例如流水 ID, 订单 ID)，在处理业务时，通过判断 ID 来防止重复处理</li></ul><h2 id="生产者-API"><a href="#生产者-API" class="headerlink" title="生产者 API"></a>生产者 API</h2><p>生产消息<br>同步与异步<br>消息确认<br>重试、批量、延迟<br>事务</p><h2 id="消费者-API"><a href="#消费者-API" class="headerlink" title="消费者 API"></a>消费者 API</h2><p>消费消息<br>自动提交与手动提交 offset<br>读取事务消息<br>Spring for Kafka</p><p>Kafka 中有一个主题 <code>__consumer_offsets</code> 用来保存消费者消费到哪个主题、哪个分区的哪个消费位置利于快速恢复</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p> 在 Kafka 中，生产者方即便事务执行中出现异常，异常前的消息也会被发送，只不过会有标记标识事务并未提交。<br> 在消费者方，可以设置 <code>isolation_level</code> 隔离级别，默认为 <code>read_uncommitted</code> 脏读，设置为 <code>read_committed</code> 只读取成功提交的数据，不会脏读</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>默认存储的二进制的形式<br><img src="http://qiniu.c77544s.top/picgo/202305121354022.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES中的倒排索引</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/ES%E4%B8%AD%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/ES%E4%B8%AD%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="http://qiniu.c77544s.top/picgo/202305112007982.png" alt="image.png"><br>Lucene 的倒排索，增加了最左边的一层「字典树」term index，它不存储所有的单词，只存储单词前缀，通过字典树找到单词所在的块，也就是单词的大概位置，再在块里二分查找，找到对应的单词，再找到单词对应的文档列表。</p><p>当然，内存寸土寸金，能省则省，所以 Lucene 还用了 FST（Finite State Transducers）对它进一步压缩。</p><p>FST 是什么？这里就不展开了，这次重点想聊的，是最右边的 Posting List 的，别看它只是存一个文档 ID 数组，但是它在设计时，遇到的问题可不少。</p><p>原生的 Posting List 有两个痛点：</p><ul><li><strong>如何压缩以节省磁盘空间</strong></li><li><strong>如何快速求交并集（intersections and unions）</strong></li></ul><h2 id="如何压缩节省磁盘空间"><a href="#如何压缩节省磁盘空间" class="headerlink" title="如何压缩节省磁盘空间"></a>如何压缩节省磁盘空间</h2><p><strong>Step 1：Delta-encode —— 增量编码</strong><br>我们只记录元素与元素之间的增量，于是数组变成了：<code>[73, 227, 2, 30, 11, 29]</code></p><p><strong>Step 2：Split into blocks —— 分割成块</strong><br>Lucene里每个块是 256 个文档 ID，这样可以保证每个块，增量编码后，每个元素都不会超过 256（1 byte）.<br>为了方便演示，我们假设每个块是 3 个文档 ID：<code>[73, 227, 2], [30, 11, 29]</code></p><p><strong>Step 3：Bit packing —— 按需分配空间</strong><br>对于第一个块，<code>[73, 227, 2]</code>，最大元素是227，需要 8 bits，好，那我给你这个块的每个元素，都分配 8 bits的空间。<br>但是对于第二个块，<code>[30, 11, 29]</code>，最大的元素才30，只需要 5 bits，那我就给你每个元素，只分配 5 bits 的空间，足矣。<br> <img src="http://qiniu.c77544s.top/picgo/202305112015943.png" alt="image.png"></p><h2 id="如何求交并集"><a href="#如何求交并集" class="headerlink" title="如何求交并集"></a>如何求交并集</h2><p><strong>Option 1: Bitmap</strong><br>假设有这样一个数组：<code>[3,6,7,10]</code><br>那么我们可以这样来表示：<code>[0,0,1,0,0,1,1,0,0,1]</code><br><strong>用 0 表示角标对应的数字不存在，用 1 表示存在。</strong></p><p>这样带来了两个好处：</p><ul><li>节省空间：既然我们只需要0和1，那每个文档 ID 就只需要 1 bit，还是假设有 100M 个文档，那只需要 100M bits &#x3D; 100M * 1&#x2F;8 bytes &#x3D; 12.5 MB，比之前用 Integer 数组 的 200 MB，优秀太多</li><li>运算更快：0 和 1，天然就适合进行位运算，求交集，「与」一下，求并集，「或」一下，一切都回归到计算机的起点</li></ul><p><strong>Option 2: Roaring Bitmaps</strong><br>bitmap 有个硬伤，就是不管有多少个文档，占用的空间都是一样的。<br>举一个极端的例子，有一个数组，里面只有两个文档 ID：<code>[0, 65535]</code><br>用 Bitmap，要怎么表示？<code>[1,0,0,0,…,(超级多个0),…,0,0,1]</code></p><p>可见在文档数量不多的时候，使用 Integer 数组更加节省内存。</p><p>我们来算一下临界值，很简单，无论文档数量多少，bitmap都需要 8192 bytes，而 Integer 数组则和文档数量成线性相关，每个文档 ID 占 2 bytes，所以：8192 &#x2F; 2 &#x3D; 4096</p><p>当文档数量少于 4096 时，用 Integer 数组，否则，用 bitmap.</p><blockquote><p>这里补充一下 Roaring bitmaps 和之前讲的 Frame Of Reference 的关系。  </p><p>Frame Of Reference 是压缩数据，减少磁盘占用空间，所以当我们从磁盘取数据时，也需要一个反向的过程，即解压，解压后才有我们上面看到的这样子的文档 ID 数组：<code>[73, 300, 302, 303, 343, 372]</code> ，接着我们需要对数据进行处理，求交集或者并集，这时候数据是需要放到内存进行处理的，我们有三个这样的数组，这些数组可能很大，而内存空间比磁盘还宝贵，于是需要更强有力的压缩算法，同时还要有利于快速的求交并集，于是有了 Roaring Bitmaps 算法。  </p><p>另外，Lucene 还会把从磁盘取出来的数据，通过 Roaring bitmaps 处理后，缓存到内存中，Lucene 称之为 filter cache. 这里补充一下 Roaring bitmaps 和之前讲的 Frame Of Reference 的关系。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL走了索引还是很慢？</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E5%BE%88%E6%85%A2%EF%BC%9F/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E5%BE%88%E6%85%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="查询速度影响因素"><a href="#查询速度影响因素" class="headerlink" title="查询速度影响因素"></a>查询速度影响因素</h2><p>MySQL 用到了索引和执行时间的长短没有必然关系，确定查询执行效率的是 “<strong>扫描行数</strong>”与“<strong>回表次数</strong>”。</p><ul><li>扫描行数</li><li>回表次数<br>在实际的 sql 优化过程中，也是尽量去优化这两块影响因素。</li></ul><h2 id="MySQL-选择-B-树索引结构的原因"><a href="#MySQL-选择-B-树索引结构的原因" class="headerlink" title="MySQL 选择 B+树索引结构的原因"></a>MySQL 选择 B+树索引结构的原因</h2><ol><li>内存占用：B+树可以把所有数据都放在叶子节点上，内部节点只存储索引信息，因此可以减少内存的占用。</li><li>顺序访问：B+树中的叶子节点之间通过链表相连，可以很方便地进行顺序访问和范围查询。</li><li>磁盘访问：对于磁盘上每个数据块大小固定的情况，B+树可以使一个节点大小等于一个数据块大小，这样可以最大化地利用磁盘容量。</li><li>多级索引：B+树支持多级索引，可以在数据量较大时不断分裂增加层数，提高查询效率。</li></ol><h2 id="聚集索引和非聚集索引（普通索引）"><a href="#聚集索引和非聚集索引（普通索引）" class="headerlink" title="聚集索引和非聚集索引（普通索引）"></a>聚集索引和非聚集索引（普通索引）</h2><ul><li>聚簇索引：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能有一个聚簇索引。<strong>叶子节点存储索引和行记录，聚簇索引查询会很快，因为可以直接定位到行记录</strong></li><li>非聚簇索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。<strong>叶子节点存储聚簇索引值（主键id），需要扫码两遍索引树，先通过普通索引定位到主键值id，再通过聚集索引定位到行记录</strong></li></ul><p>InnoDB 必须有一个主键索引，这里给 id 为主键，其次有 a、b 两个字段，再给 a 字段（姓名字段）一个普通索引，目前就有了主键索引和 a 索引树结构，如下图所示：<br><img src="http://qiniu.c77544s.top/picgo/202305111746033.png" alt="image.png"></p><blockquote><p>InnoDB 默认有主键索引，存储的是主键 id 1、2、3…，它是采用 B+ tree 的聚簇索引，所有的数据都存放在叶子结点中，而普通索引 a 采用非聚集索引，数据只包含对应的 id，没有整行数据，所以如果通过普通索引找到了某个 id，需要 select 别的字段，则还需要回表找主键索引中的整行数据取值！</p></blockquote><h2 id="几种调优方式"><a href="#几种调优方式" class="headerlink" title="几种调优方式"></a>几种调优方式</h2><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>索引覆盖，即将查询 sql 中的字段添加到联合索引里面，只要保证查询语句里面的字段都在索引文件中，就无需进行回表查询；</p><h3 id="索引下推（系统优化）"><a href="#索引下推（系统优化）" class="headerlink" title="索引下推（系统优化）"></a>索引下推（系统优化）</h3><p>在 MySQL5.6的版本中推出，用于优化查询。<strong>在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><h3 id="自查询（优化分页）"><a href="#自查询（优化分页）" class="headerlink" title="自查询（优化分页）"></a>自查询（优化分页）</h3><p>优化<strong>超多分页的场景</strong>。查询条件放到子查询中，子查询只查主键，然后使用子查询中确认的主键关联其他属性字段。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>比如要插入的很多连续的数据值都一样，则可以压缩成一条数据插入。</p><h3 id="硬件调优"><a href="#硬件调优" class="headerlink" title="硬件调优"></a>硬件调优</h3><p>增大 innodb buffer pool 多利用内存,减少硬盘回表</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>幂等是一个数学与计算机科学概念。</p><ul><li>在数学中，幂等用函数表达式就是：<code>f(x)=f(f(x))</code>。比如求绝对值的函数，就是幂等<br>的，<code>abs(x)=abs(abs(x))</code>。</li><li>计算机科学中，幂等表示一次和多次请求某一个资源应该具有同样的副作用，或者说，多<br>次请求所产生的影响与一次请求执行的影响效果相同。</li></ul><h2 id="如何设计幂等"><a href="#如何设计幂等" class="headerlink" title="如何设计幂等"></a>如何设计幂等</h2><p>幂等处理的过程，说到底其实就是过滤一下己经收到的请求，当然，请求一定要有一个<br><code>全局唯一的 D 标记 </code>。然后，怎么判断请求是否之前收到过呢？把请求储存起来，收到<br>请求时，先查下存储记录，记录存在就返回上次的结果，不存在就处理请求。<br><img src="http://qiniu.c77544s.top/picgo/202305111620137.png" alt="image.png"></p><h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="select（可省）-insert-主键-x2F-唯一索引冲突"><a href="#select（可省）-insert-主键-x2F-唯一索引冲突" class="headerlink" title="select（可省） + insert + 主键&#x2F;唯一索引冲突"></a>select（可省） + insert + 主键&#x2F;唯一索引冲突</h3><p>交易请求过来，我会先根据请求的<strong>唯一流水号</strong> <code>bizseq</code> 字段，先 <code>select</code> 一下数据库的流水表</p><ul><li>如果数据已经存在，就拦截是重复请求，直接返回成功：</li><li>如果数据不存在，就执行 <code>insert</code> 插入，如果 <code>insert</code> 成功，则直接返回成功，如果 <code>insert</code> 产生主键冲突异常，则捕获异常，接着直接返回成功。</li></ul><h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><p>很多业务表，都是有状态的，比如转账流水表，就会有 <code>0-待处理，1-处理中、2-成功、3-失败状态 </code>.转账流水更新的时候，都会涉及流水状态更新，即涉及状态机（即状态变更图）。</p><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><p>第一种是建立在业务流水表上 <code>bizseq</code> 的唯一性上。很多时候，我们业务表唯一流水号希望后端系统生成，又或者我们希望防重功能与业务表分隔开来，这时候我们可以单独搞个防重表。当然防重表也是利用主键&#x2F;索引的唯一性，如果插入防重表冲突即直接返回成功，如果插入成功，即去处理请求。</p><h3 id="token-令牌"><a href="#token-令牌" class="headerlink" title="token 令牌"></a>token 令牌</h3><ol><li>客户端请求申请获取 token, 服务端生成 token 返回</li><li>客户端带着 token 请求，服务端校验 token，token 存在则判断为第一次请求，token 不存在则为重复请求。</li></ol><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>比如 <code>select for update</code>，配合事务实现幂等，注意这种锁要使用主键查询<br><img src="http://qiniu.c77544s.top/picgo/202305111642701.png" alt="image.png"><br>一般不建议使用悲观锁实现幂等</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>就是给表的加多一列 <code>version</code> 版本号，每次更新记录 <code>version</code> 都升级一下 <code>(version=version+1)</code>。具体流程就是先查出当前的版本号 <code>version</code>,然后去更新修改数据时，确认下是不是刚刚查出的版本号，如果是才执行更新。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁实现幂等性的逻辑就是，请求过来时，先去尝试获得分布式锁，如果获得成功，就执行业务逻辑，反之获取失败的话，就舍弃请求直接返回成功。</p><ul><li>Redis 分布式锁，可以使用命令 <code>SET EX PX NX+唯一流水号</code> 实现，分布式锁的 <code>key</code> 必须为业务的唯一标识</li><li>Redis 执行设置 key 的动作时，要设置过期时间，这个过期时间不能太短，太短拦截不了重复请求，也不能设置太长，会占存储空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC原理</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/MVCC%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/MVCC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的四大特性—ACID"><a href="#事务的四大特性—ACID" class="headerlink" title="事务的四大特性—ACID"></a>事务的四大特性—ACID</h2><p>事务四个典型特性，即ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><ul><li>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。</li><li>一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li><li>隔离性： 多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。。</li><li>持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h2 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h2><p><strong>脏读</strong></p><blockquote><p>一个事务读取到了另一个未提交事务修改过的数据</p></blockquote><p><strong>不可重复读</strong></p><blockquote><p>同一个事务内，前后多次读取，读取到的数据内容不一致</p></blockquote><p><strong>幻读</strong></p><blockquote><p>一个事务根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录，第一个事务再查时发现数据不一致，与不可重复读的区别在于这里的是插入。</p></blockquote><h2 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交（RC）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读（RR）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>数据库隔离级别的 <strong>读已提交、可重复读</strong> 都是基于 MVCC 实现的</p><h2 id="MVCC-的关键知识点"><a href="#MVCC-的关键知识点" class="headerlink" title="MVCC 的关键知识点"></a>MVCC 的关键知识点</h2><h3 id="事务版本号"><a href="#事务版本号" class="headerlink" title="事务版本号"></a>事务版本号</h3><blockquote><p>事务每次开启前，都会从数据库获得一个<strong>自增</strong>长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p></blockquote><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>单调递增的行ID，不是必需的，占用6个字节。</td></tr><tr><td>trx_id</td><td>是</td><td>记录操作该数据事务的事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>这个隐藏列就相当于一个指针，指向回滚段的undo日志</td></tr></tbody></table><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><strong>回滚日志</strong>，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。</p><p>undo log有什么<strong>用途</strong>呢？</p><ol><li>事务回滚时，保证原子性和一致性。</li><li>用于MVCC<strong>快照读</strong></li></ol><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69abb7c89d1e4d9f8e242d9e0a410e3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="版本链"></p><h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p><strong>快照读：</strong> 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读。</p><p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> core_user <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>上在innodb中，每个SQL语句执行前都会得到一个Read View，用来做可见性判断的，即判断当前事务可见哪个版本的数据~</p><p>Read View是如何保证可见性判断的呢？我们先看看Read view 的几个重要属性</p><ul><li>m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。</li><li>min_limit_id:表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</li><li>max_limit_id:表示生成ReadView时，系统中应该分配给下一个事务的id值。</li><li>creator_trx_id: 创建当前read view的事务ID</li></ul><p><strong>Read view 匹配条件规则</strong>如下：</p><ol><li>如果数据事务ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>,需腰分3种情况讨论</li></ol><blockquote><ul><li>（1）.如果<code>m_ids</code>包含<code>trx_id</code>,则代表Read View生成时刻，这个事务还未提交，但是如果数据的<code>trx_id</code>等于<code>creator_trx_id</code>的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</li><li>（2）如果<code>m_ids</code>包含<code>trx_id</code>，并且<code>trx_id</code>不等于<code>creator_trx_id</code>，则Read   View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</li><li>（3）.如果<code>m_ids</code>不包含<code>trx_id</code>，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li></ul></blockquote><h2 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h2><ol><li>获取事务自己的版本号，即事务ID</li><li>获取Read View</li><li>查询得到的数据，然后Read View中的事务版本号进行比较。</li><li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li><li>最后返回符合规则的数据</li></ol><p>InnoDB 实现MVCC，是通过<code> Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。</p><h3 id="不同隔离级别下，Read-view的工作方式不同"><a href="#不同隔离级别下，Read-view的工作方式不同" class="headerlink" title="不同隔离级别下，Read view的工作方式不同"></a>不同隔离级别下，Read view的工作方式不同</h3><ul><li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li><li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li></ul><p>作者：捡田螺的小男孩<br>链接：<a href="https://juejin.cn/post/7016165148020703246">https://juejin.cn/post/7016165148020703246</a><br>来源：稀土掘金</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中的跳表</title>
      <link href="/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%A1%A8/"/>
      <url>/2023/05/11/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><code>Redis</code> 只在两个地方用到了跳跃表，一个是实现有序集合键（sorted set），另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在 <code>Redis</code> 里面没有其他用途。</p><p><img src="http://qiniu.c77544s.top/picgo/202305111157625.png" alt="image.png"></p><p>sorted set 同时使用压缩列表和跳表<br>在下列情况下使用压缩列表，否则使用跳表</p><ol><li>有序集合保存的元素数量小于 128 个</li><li>有序集合保存的所有元素的长度小于 64 字节</li></ol><p>为什么使用跳表而不使用红黑树或平衡树？</p><ol><li>zset 支持范围查找，跳表更好实现</li><li>跳表实现相对简单</li></ol><p><img src="http://qiniu.c77544s.top/picgo/202305111438516.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行流</title>
      <link href="/2023/05/10/%E5%90%8E%E7%AB%AF/Java/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
      <url>/2023/05/10/%E5%90%8E%E7%AB%AF/Java/%E5%B9%B6%E8%A1%8C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>并行流通过 <code>list.parallelStream()</code> 方法。当然也可以通过 <code>list.stream().parallel()</code> 将普通流转换成并行流。并行流也能通过 <code>sequential()</code> 方法转换为顺序流。但是：<strong>流的并行和顺序转换不会对流本身做任何实际的变化，仅仅是打了个标记而已。并且在一条流水线上对流进行多次并行 &#x2F; 顺序的转换，生效的是最后一次的方法调用</strong></p><blockquote><p>&#x3D;&#x3D;并行流内部使用了默认的 ForkJoinPool 线程池。<strong>默认的线程数量就是处理器的核心数</strong>&#x3D;&#x3D;，而配置系统核心属性：java.util.concurrent.ForkJoinPool.common.parallelism 可以改变线程池大小。不过该值是全局变量。改变他会影响所有并行流。目前还无法为每个流配置专属的线程数。一般来说采用处理器核心数是不错的选择</p></blockquote><h2 id="并行流并不可以随便用"><a href="#并行流并不可以随便用" class="headerlink" title="并行流并不可以随便用"></a>并行流并不可以随便用</h2><h3 id="可拆分性影响流的速度"><a href="#可拆分性影响流的速度" class="headerlink" title="可拆分性影响流的速度"></a>可拆分性影响流的速度</h3><ol><li>iterate 方法处理前 n 个数，比如 <code>Stream.iterate(1L, i -&gt; i + 1).limit(n).parallel()</code><ol><li>iterate 生成的是装箱的对象，必须拆箱成数字才能求和</li><li>对于 iterate 来说，每次应用这个函数都要依赖于前一次应用的结果。不仅不能有效的将流划分成小块处理。反而还因为并行化再次增加了开支。</li></ol></li><li>对于 <code>LongStream.rangeClosed()</code> 方法生成前 n 个数来说，就不存在 iterate 点问题，它生成的是基本类型的值，另外它可以直接将要生成的数字拆分成多个部分，并行状态下 <code>rangeClosed()</code> 是快于 for 循环外部迭代的。</li></ol><h3 id="共享变量修改的问题"><a href="#共享变量修改的问题" class="headerlink" title="共享变量修改的问题"></a>共享变量修改的问题</h3><p>因为是多线程，所以存在线程问题。</p><h3 id="并行流的使用注意"><a href="#并行流的使用注意" class="headerlink" title="并行流的使用注意"></a><strong>并行流的使用注意</strong></h3><ul><li>尽量使用 LongStream &#x2F; IntStream &#x2F; DoubleStream 等原始数据流代替 Stream 来处理数字，以避免频繁拆装箱带来的额外开销</li><li>要考虑流的操作流水线的总计算成本，假设 N 是要操作的任务总数，Q 是每次操作的时间。N * Q 就是操作的总时间，Q 值越大就意味着使用并行流带来收益的可能性越大。</li><li>对于较少的数据量，不建议使用并行流</li><li>容易拆分成块的流数据，建议使用并行流</li></ul><p>以下是一些常见的集合框架对应流的可拆分性能表<br><img src="http://qiniu.c77544s.top/picgo/202305101704679.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务产生的场景"><a href="#分布式事务产生的场景" class="headerlink" title="分布式事务产生的场景"></a>分布式事务产生的场景</h2><ul><li><strong>跨 JVM 进程产生分布式事务</strong><br><img src="http://qiniu.c77544s.top/picgo/202305101502764.png" alt="image.png"></li><li><strong>跨数据库实例产生分布式事务</strong><br><img src="http://qiniu.c77544s.top/picgo/202305101504958.png" alt="image.png"></li><li><strong>多服务访问同一个数据库实例</strong><br><img src="http://qiniu.c77544s.top/picgo/202305101504389.png" alt="image.png"></li></ul><h2 id="分布式事务的基础理论"><a href="#分布式事务的基础理论" class="headerlink" title="分布式事务的基础理论"></a>分布式事务的基础理论</h2><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>CAP 是 Consistency、Availability、Partition tolerance 三个单词的缩写，分别表示一致性、可用性、分区容忍性。</p><ol><li>C - Consistency    一致性</li><li>A - Availability   可用性</li><li>P - Partition tolerance    分区容忍性</li></ol><p><strong>CAP 的组合方式</strong></p><ol><li>AP<ol><li>放弃一致性，追求分区容忍性和可用性，只要保证最终一致性就行。这是很多分布式系统设计时的选择。因为大部分业务用户都能够接受在一段时间内获取不到最新的数据，最要最终能够获取到就可以。</li></ol></li><li>CP<ol><li>放弃可用性，追求一致性和分区容错性，zookeeper 其实就是追求的强一致，又比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</li></ol></li><li>CA<ol><li>放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统，最常用的关系型数据就满足了 CA。</li></ol></li></ol><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><blockquote><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。BASE 理论是对 CAP 中 AP 的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足 BASE 理论的事务，我们称之为“<strong>柔性事务</strong>”。  </p></blockquote><ol><li><strong>基本可用</strong>：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。</li><li><strong>软状态</strong>：由于不要求强一致性，所以 BASE 允许系统中存在中间状态（也叫<strong>软状态</strong>），这个状态不影响系统可用性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。</li><li><strong>最终一致</strong>：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ol><p>针对不同的分布式场景业界常见的解决方案有 <strong>2PC、3PC、TCC、可靠消息最终一致性、最大努力通知</strong>这几种</p><h2 id="2PC-解决方案"><a href="#2PC-解决方案" class="headerlink" title="2PC 解决方案"></a>2PC 解决方案</h2><h3 id="什么是-2PC"><a href="#什么是-2PC" class="headerlink" title="什么是 2PC"></a>什么是 2PC</h3><p>2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。</p><p>在计算机中部分关系数据库如 Oracle、MySQL 支持两阶段提交协议：</p><ol><li>准备阶段（Prepare phase）：事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo&#x2F;Redo 日志，此时事务没有提交。（Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件）</li><li>提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：<strong>必须在最后阶段释放锁资源</strong>。</li></ol><h3 id="XA-解决方案"><a href="#XA-解决方案" class="headerlink" title="XA 解决方案"></a>XA 解决方案</h3><p>2PC 的传统方案是在数据库层面实现的，如 Oracle、MySQL 都支持 2PC 协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织 Open Group 定义了分布式事务处理模型<strong>DTP</strong>（Distributed Transaction Processing Reference Model）。<br>下面以新用户注册送积分为例来说明 XA 方案：<br><img src="http://qiniu.c77544s.top/picgo/202305111040213.png" alt="image.png"><br>执行流程如下：</p><ol><li>应用程序（AP）持有用户库和积分库两个数据源。</li><li>应用程序（AP）通过 TM 通知用户库 RM 新增用户，同时通知积分库RM为该用户新增积分，RM 此时并未提交事务，此时用户和积分资源锁定。</li><li>TM 收到执行回复，只要有一方失败则分别向其他 RM 发起回滚事务，回滚完毕，资源锁释放。</li><li>TM 收到执行回复，全部成功，此时向所有 RM 发起提交事务，提交完毕，资源锁释放。</li></ol><p>DTP 模型定义如下角色：</p><ul><li><strong>AP</strong>（Application Program）：即应用程序，可以理解为使用 DTP 分布式事务的程序。</li><li><strong>RM</strong>（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。</li><li><strong>TM</strong>（Transaction Manager）：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个 RM。<strong>全局事务</strong>是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。</li><li>DTP 模型定义 TM 和 RM 之间通讯的接口规范叫 <strong>XA</strong>，简单理解为数据库提供的 2PC 接口协议，<strong>基于数据库的 XA 协议来实现 2PC 又称为 XA 方案</strong></li></ul><p><strong>XA 方案的问题</strong></p><ol><li>需要本地数据库支持XA协议。</li><li>资源锁需要等到两个阶段结束才释放，性能较差</li></ol><h3 id="Seata-方案"><a href="#Seata-方案" class="headerlink" title="Seata 方案"></a>Seata 方案</h3><p>Seata 是由阿里中间件团队开源的分布式事务框架。</p><p>Seata 通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是<strong>工作在应用层</strong>的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务 0 侵入的方式解决微服务场景下面临的分布式事务问题，它目前提供 AT 模式（即 2PC）及 TCC 模式的分布式事务解决方案。</p><p>Seata 把一个分布式事务理解成一个包含了若干<strong>分支事务</strong>的<strong>全局事务</strong>。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务。</p><ul><li>Transaction Coordinator（TC）：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收 TM 指令发起全局事务的提交与回滚，负责与 RM 通信协调各各分支事务的提交或回滚。</li><li>Transaction Manager（TM）： 事务管理器，TM 需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向 TC 发起全局提交或全局回滚的指令。</li><li>Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚。<br><img src="http://qiniu.c77544s.top/picgo/202305111045883.png" alt="image.png"><br>具体的执行流程如下：</li></ul><ol><li>用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。  </li><li>用户服务的 RM 向 TC 注册分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖。</li><li>用户服务执行分支事务，向用户表插入一条记录。  </li><li>逻辑执行到远程调用积分服务时（XID 在微服务调用链路的上下文中传播）。积分服务的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。  </li><li>积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。  </li><li>用户服务分支事务执行完毕。  </li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。  </li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li><li><strong>Seata 实现2PC 与传统2PC 的差别</strong><br><strong>架构层次方面</strong>：传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的。<br><strong>两阶段提交方面</strong>：传统 2PC 无论第二阶段的决议是 commit 还是 rollback ，事务性资源的锁都要保持到 Phase2 完成才释放。而 Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效率。</li></ol><h2 id="TCC-解决方案"><a href="#TCC-解决方案" class="headerlink" title="TCC 解决方案"></a>TCC 解决方案</h2><p>TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm&#x2F;Cancel 操作若执行失败，TM 会进行重试。</p><p>TCC 分为三个阶段：</p><ol><li><strong>Try</strong> 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑。</li><li><strong>Confirm</strong> 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。</li><li><strong>Cancel</strong> 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。</li></ol><h3 id="TCC-异常处理"><a href="#TCC-异常处理" class="headerlink" title="TCC 异常处理"></a>TCC 异常处理</h3><p>TCC 需要注意三种异常处理分别是<strong>空回滚</strong>、<strong>幂等</strong>、<strong>悬挂</strong></p><p>TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条，可通过额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID。比如，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。</p><ol><li><strong>空回滚</strong><br>在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚（分支事务记录表中没 try 数据），然后直接返回成功。</li><li>幂等<br> TCC 二阶段提交重试机制可能会造成数据不一致，要求 TCC 的二阶段 Try、Conﬁrm 和 Cancel 接口保证幂等</li><li>悬挂<br>悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。<br>出现原因是在 RPC 调用分支事务 Try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行。而该分布式事务第一阶段预留的业务资源就再也没有人能够处理了<br>解决思路是：”分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行 Try。</li></ol><p>如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让<strong>应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能</strong>。</p><h2 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h2><p>可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方（消息消费者）一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。<br><img src="http://qiniu.c77544s.top/picgo/202305111110457.png" alt="image.png"><br>可靠消息最终一致性方案要解决以下几个问题：</p><ol><li><strong>本地事务与消息发送的原子性问题</strong><br>本地事务与消息发送的原子性问题即：要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。<br>下面这种操作，先发送消息，在操作数据库：<br><code>mysql begin transaction； //1.发送MQ //2.数据库操作 commit transation;</code><br>这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。 那么第二种方案，先进行数据库操作，再发送消息：<br><code>mysql begin transaction； //1.数据库操作 //2.发送MQ commit transation;</code><br>这种情况下貌似没有问题，如果发送 MQ 消息失败，就会抛出异常，导致数据库事务回滚。但如果是超时异常，数据库回滚，但 MQ 其实已经正常发送了，同样会导致不一致。  </li><li><strong>事务参与方接收消息的可靠性</strong><br>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。  </li><li><strong>消息重复消费的问题</strong><br>由于网络2的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。<br>要解决消息重复消费的问题就要实现事务参与方的方法幂等性。</li></ol><h3 id="解决方案：本地消息表方案"><a href="#解决方案：本地消息表方案" class="headerlink" title="解决方案：本地消息表方案"></a>解决方案：本地消息表方案</h3><p>此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。<br><img src="http://qiniu.c77544s.top/picgo/202305111114290.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性：</p><ol><li>本地事务与消息发送的原子性问题。</li><li>事务参与方接收消息的可靠性。</li></ol><p>可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p><h2 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h2><p><img src="http://qiniu.c77544s.top/picgo/202305111137304.png" alt="image.png"><br>交互流程：</p><ol><li>账户系统调用充值系统接口</li><li>充值系统完成支付处理向账户发起充值结果通知，若通知失败，则充值系统按策略进行重复通知</li><li>账户系统接收到充值结果通知修改充值状态</li><li>账户系统未接收到通知会主动调用充值系统的接口查询充值结果</li></ol><p>通过上边的例子我们总结最大努力通知方案的目标：<strong>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方</strong>。</p><ol><li>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知</li><li>消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>方案 1 :<br><img src="http://qiniu.c77544s.top/picgo/202305111139581.png" alt="image.png"><br>本方案是利用 MQ 的 ack 机制由 MQ 向接收通知方发送通知<br>方案 2 ：<br><img src="http://qiniu.c77544s.top/picgo/202305111140811.png" alt="image.png"><br><strong>方案1和方案2的不同点</strong>：</p><ol><li>方案 1 中接收通知方与 MQ 接口，即接收通知方案监听 MQ，此方案主要应用与内部应用之间的通知。</li><li>方案 2 中由通知程序与 MQ 接口，通知程序监听 MQ，收到 MQ 的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>分布式事务对比分析</strong></p><p><strong>2PC</strong> 最大的诟病是一个阻塞协议。RM 在执行分支事务后需要等待 TM 的决定，此时服务会阻塞并锁定资源。由于其阻塞机制和最差时间复杂度高，因此，这种设计不能适应随着事务涉及的服务数量增加而扩展的需要，很难用于并发较高以及子事务生命周期较长（long-running transactions） 的分布式服务中。</p><p>如果拿<strong>TCC</strong>事务的处理流程与2PC两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让<strong>应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能</strong>。而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 Try、Conﬁrm、Cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实 现不同的回滚策略。典型的使用场景：满减，登录送优惠券等。</p><p><strong>可靠消息最终一致性</strong>事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。典型的使用场景：注册送积分，登录送优惠券等。</p><p><strong>最大努力通知</strong>是分布式事务中要求最低的一种,适用于一些最终一致性时间敏感度低的业务；允许发起通知方处理业务失败，在接收通知方收到通知后积极进行失败处理，无论发起通知方如何处理结果都会不影响到接收通知方的后续处理；发起通知方需提供查询执行情况接口，用于接收通知方校对结果。典型的使用场景：银行通知、支付结果通知等。<br><img src="http://qiniu.c77544s.top/picgo/202305111141517.png" alt="image.png"></p><p>无论是数据库层的 XA、还是应用层 TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。</p><p><a href="https://zhuanlan.zhihu.com/p/263555694">分布式事务有这一篇就够了！ - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁的实现</title>
      <link href="/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/10/%E5%90%8E%E7%AB%AF/Spring%20Cloud/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基于-Redis-实现"><a href="#基于-Redis-实现" class="headerlink" title="基于 Redis 实现"></a>基于 Redis 实现</h2><p>相关概念：</p><ul><li>setnx</li><li>lua</li><li>redisson</li><li>redlock</li></ul><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h3><p>目前通常所说的 setnx ( <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists ) 命令，并非单指 redis 的 setnx key value 这条命令（因为未来 redis 可能要废除 setnx 命令）。<br>一般代指redis中对<strong>set</strong>命令加上<strong>nx</strong>参数进行使用， <strong>set</strong>这个命令，目前已经支持这么多参数可选：<br><code>SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</code><br>其中 <code>EX</code> 和 <code>PX</code> 参数设置过期时间<br><code>NX</code> ：只在键不存在时，才对键进行设置操作。执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code><br><code>XX</code>：只在键已经存在时，才对键进行设置操作。</p><blockquote><p>在设置分布式锁时，要保证 value 值唯一，通常是<strong>UUID + threadId</strong>，在删除缩时判断 value 是否是当前线程加的锁</p></blockquote><p>setnx 的方式虽然在加锁的时候可以保证原子性，但是在解锁时要先获取 value 再删除，无法保证原子性，可以用 lua 脚本实现原子性的解锁操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua删除锁：</span></span><br><span class="line"><span class="comment">-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。</span></span><br><span class="line"><span class="comment">-- 如果对应的value等于传入的uuid。</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line"><span class="comment">-- 执行删除操作</span></span><br><span class="line">        <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"><span class="comment">-- 不成功，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用 setnx 还存在锁续期等问题</p><h3 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h3><p>redisson 中<strong>加锁&#x2F;释放锁</strong>操作都是用<strong>lua</strong>脚本完成的，封装的非常完善，开箱即用。<br>此外，redisson 中通过 <code>watch dog</code> 机制实现了锁续期的功能，锁的可靠性上更加完善。<br>同时，redisson 实现的锁是可重入的。</p><h4 id="Watch-dog"><a href="#Watch-dog" class="headerlink" title="Watch dog"></a>Watch dog</h4><p><img src="http://qiniu.c77544s.top/picgo/202210121456281.png" alt="img"><br>redisson 在获取锁的时候，默认的 ttl 是30秒，Watch dog 会每隔10秒看一下，如果还持有锁，将 ttl 续期30s（可以通过修改 Config.lockWatchdogTimeout 来另行指定），从而实现分布式锁的续期。</p><ol><li>watch dog 在当前节点存活时每10s给分布式锁的key续期 30s；</li><li>watch dog 机制启动，且代码中没有释放锁操作时，watch dog 会不断的给锁续期；</li><li>从可2得出，如果程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；</li></ol><p>&#x3D;&#x3D;redisson 方案存在的问题：**&#x3D;&#x3D;</p><ol><li><strong>长时间的 GC pause：</strong> 如果 watch dog 所在服务在续期之前，JVM 进行的 <code>STW</code>，而 <code>STW</code> 的时间又很长，长到超过了锁的过期时间，这样就会出现程序还没有释放锁，但是又会被其他线程锁上。</li><li><strong>时钟发生跳跃：</strong> 对于 Redis 服务器如果其时间发生了向跳跃，那么肯定会影响我们锁的过期时间，那么我们的锁过期时间就不是我们预期的了，也会出现 client1和 client2获取到同一把锁，那么也会出现不安全，这个对于 Mysql 也会出现。但是 ZK 由于没有设置过期时间，那么发生跳跃也不会受影响。</li><li><strong>长时间的网络 I&#x2F;O</strong>：这个问题和我们的 GC 的 STW 很像，也就是我们这个获取了锁之后我们进行网络调用，其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题，这个 Mysql 也会有，ZK 也不会出现这个问题。</li></ol><h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>首先 RedLock 的实现需要有 N 个 Redis Master。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>（RedLock 依赖的环境不能是一个由 N 主 N 从组成的 Cluster 集群模式，因为 Cluster 模式下的各个 Master 并不完全独立，而是存在 Gossip 协调机制的）。之所以要用独立的，是避免了 redis 异步复制造成的锁丢失，比如：主节点没来的及把<strong>刚刚 set 进来这条数据</strong>给从节点，就挂了。<br><img src="http://qiniu.c77544s.top/picgo/202305101419734.png" alt="image.png"></p><p>红锁算法认为，只要2N + 1个节点加锁成功，那么就认为获取了锁，解锁时将所有实例解锁。流程为：</p><ol><li>顺序向五个节点请求加锁</li><li>根据一定的<strong>超时时间</strong>来推断是不是跳过该节点</li><li>三个节点加锁成功并且花费时间小于锁的有效期</li><li>认定加锁成功</li></ol><blockquote><p>Redisson 中已经封装好了 RedLock 的开源实现。</p></blockquote><p>RedLock 方案相比普通的 Redis 分布式锁方案<strong>可靠性</strong>确实大大提升，但一般业务中只需要一个 Redis Cluster，或者一个 Sentinel，但是这两者都不能承载 RedLock 的落地。</p><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>基本原理和 Redis 的 SETNX 类似，其实就是创建一个分布式锁表，加锁后，在表增加一条记录，释放锁即把该数据删掉。<br><img src="http://qiniu.c77544s.top/picgo/202305101439972.png" alt="image.png"></p><p><strong>它同样存在一些问题：</strong></p><ol><li>没有失效时间，容易导致死锁；</li><li>依赖数据库的可用性，一旦数据库挂掉，锁就马上不可用；</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作；</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库中数据已经存在了。</li></ol><ul><li>优点:理解起来简单，不需要维护额外的第三方中间件(比如 Redis,Zk)。</li><li>缺点:虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。</li></ul><h2 id="基于-Zookeeper-的分布式锁"><a href="#基于-Zookeeper-的分布式锁" class="headerlink" title="基于 Zookeeper 的分布式锁"></a>基于 Zookeeper 的分布式锁</h2><p>实现原理为：</p><ol><li>建立一个节点，假如名为 lock 。节点类型为持久节点（Persistent）</li><li>每当进程需要访问共享资源时，会调用分布式锁的 lock() 或 tryLock() 方法获得锁，这个时候会在第一步创建的 lock 节点下建立相应的顺序子节点，节点类型为临时顺序节点（<code>EPHEMERAL_SEQUENTIAL</code>），通过组成特定的名字 name+lock+顺序号。</li><li>在建立子节点后，对 lock 下面的所有以 name 开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。</li><li>假如不是该节点，就获得该节点的上一顺序节点，并监测该节点是否存在注册监听事件。同时在这里阻塞，等待监听事件的发生（watcher），获得锁控制权。(这里的watcher其实调用的是object.notifyAll(),用来解除阻塞)。</li><li>当调用完共享资源后，调用 unlock() 方法，关闭 ZooKeeper，进而可以引发监听事件，释放该锁。</li></ol><p><img src="http://qiniu.c77544s.top/picgo/202305101443186.png" alt="image.png"></p><ul><li>优点: ZK 可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，ZK 获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用 ZK 集群进行保证。</li><li>缺点:ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 如何提高接口数据安全性</title>
      <link href="/2023/05/08/%E5%90%8E%E7%AB%AF/Spring%20Boot/Spring%20Boot%20%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2023/05/08/%E5%90%8E%E7%AB%AF/Spring%20Boot/Spring%20Boot%20%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在 Spring Boot 项目中提高接口安全的核心所在：<strong>加密和加签</strong>，加固接口参数、验证复杂度。</p><p><strong>加密：</strong> 对参数进行加密传输，拒绝接口参数直接暴露，这样就可以有效做到防止别人轻易准确地获取到接口参数定义和传参格式要求了。</p><p><strong>加签：</strong> 对接口参数进行加签，可以有效防止接口参数被篡改和接口参数被重放恶刷。</p><h2 id="1-加密"><a href="#1-加密" class="headerlink" title="1. 加密"></a>1. 加密</h2><p>采用<strong>非对称加密算法 RSA 和对称加密算法 AES</strong>来完成接口加密</p><blockquote><p><strong>AES 是对称加密算法</strong>，优点：加密速度快；缺点：如果秘钥丢失，就容易解密密文，安全性相对比较差<br><strong>RSA 是非对称加密算法</strong> ，优点：安全；缺点：加密速度慢</p></blockquote><p>接口参数加解密的流程大致如图所示：<br><img src="http://qiniu.c77544s.top/picgo/202305091014736.png" alt="接口参数加解密流程.png"></p><h2 id="2-验签"><a href="#2-验签" class="headerlink" title="2. 验签"></a>2. 验签</h2><p>签名验证也是当下提高接口安全性主要措施之一，核心就是客户端在调用接口时按照一定规则生成签名 <code>sign</code>，服务端拿到签名 <code>sign</code> 之后进行验证操作，大致流程如下：<br><img src="http://qiniu.c77544s.top/picgo/202305091016734.png" alt="image.png"></p><h2 id="3-优雅实现接口加密、加签"><a href="#3-优雅实现接口加密、加签" class="headerlink" title="3. 优雅实现接口加密、加签"></a>3. 优雅实现接口加密、加签</h2><p>对加密、加签操作进行了公共的抽取封装，同时通过一个注解 <code>@ApiSecurity</code> 来标识接口是否需要进行加密、加签操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiSecurity &#123;​</span><br><span class="line">    <span class="meta">@Alias(&quot;isSign&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加签验证，默认开启</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Alias(&quot;value&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSign</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口请求参数是否需要解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">decryptRequest</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口响应参数是否需要加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">encryptResponse</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注解属性可以看到签名验证默认是开启的，因为我们认为接口安全性加签是必须的，至于参数加解密可以视情况而定。<br>使用案例：下面就是一个需要加密加签的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/security&quot;)</span></span><br><span class="line"><span class="meta">@ApiSecurity(encryptResponse = true, decryptRequest = true)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">testApiSecurity</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对接口加密、加签功能实现统一和规范，这里将实现抽取，封装集成在自定义的 <code>web starter</code> 中，这样只要项目服务引入这个 starter 依赖就可以使用该功能了</p><p>首先对加密传输的参数 bean 进行规定封装如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiSecurityParam</span> &#123;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA加密后的aes秘钥，需解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES加密的json参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String data;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sign;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String timestamp;​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nonce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等于说加密、加签的参数格式，调用方需按照上面的对象传参，当然为了提高拓展性，签名的相关信息 <code>sign、timestamp、nonce</code> 可以放到请求的 <code>header</code> 里面，也能获取到。拿到 <code>apiSecurityParam</code> 我们就可以进行请求参数解密、验签了，需要通过判断是否使用了注解 <code>@ApiSecuriy</code> 来决定是否执行请求参数解密、验签逻辑，这就正好可以使用基于注解的切面实现啦，在说切面之前，先说说一次接口请求 <code>requestBody</code> 的输入流 InputStream 只能读取一次，就是说 <code>request.getInputStream()</code> 只能使用一次，原因如下：</p><p><strong>因为流对应的是数据，数据放在内存中，有的是部分放在内存中。read 一次标记一次当前位置（mark position），第二次read就从标记位置继续读（从内存中copy）数据。 所以这就是为什么读了一次第二次是空了。 怎么让它不为空呢？只要inputstream 中的pos 变成0就可以重写读取当前内存中的数据。javaAPI中有一个方法public void reset() 这个方法就是可以重置pos为起始位置，但是不是所有的IO读取流都可以调用该方法！ServletInputStream是不能调用reset方法，这就导致了只能调用一次getInputStream()。</strong></p><p>而我们需要先读取出<code>requestBody</code>进行解密，然后拿到解密之前的参数映射到真正的接口方法参数对象里，所以必须解决这个问题。</p><p>解决方法就是原始的<code>HttpServletRequest</code>的InputStream只能读取一下，那么我们就重新自定义封装一个<code>HttpServletRequest</code>可以实现多次读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestBodyWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//用于将流保存下来</span></span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RequestBodyWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">        body = <span class="keyword">new</span> <span class="title class_">String</span>(StreamUtils.copyToByteArray(request.getInputStream()), StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写getInputStream， 从body中获取请求参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">ServletInputStream</span> <span class="variable">servletInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener readListener)</span> &#123;</span><br><span class="line">​</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> servletInputStream;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String body)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>接下来就可以来看看切面了：这里是解析请求参数和验签和逻辑所在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Order(value = OrderConstant.AOP_API_DECRYPT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiSecurityAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApiSecurityProperties apiSecurityProperties;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NONCE_KEY</span> <span class="operator">=</span> <span class="string">&quot;x-nonce-&quot;</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.plasticene..controller..*(..)) &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;(@annotation(com.plasticene.boot.web.core.anno.ApiSecurity) ||&quot; +</span></span><br><span class="line"><span class="meta">            &quot; @target(com.plasticene.boot.web.core.anno.ApiSecurity))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">securityPointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Around(&quot;securityPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundApiSecurity</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//=======AOP解密切面通知=======</span></span><br><span class="line">        <span class="type">ApiSecurity</span> <span class="variable">apiSecurity</span> <span class="operator">=</span> getApiSecurity(joinPoint);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSign</span> <span class="operator">=</span> apiSecurity.isSign();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">decryptRequest</span> <span class="operator">=</span> apiSecurity.decryptRequest();</span><br><span class="line">        <span class="comment">// 获取request加密传递的参数</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> getRequest();</span><br><span class="line">        <span class="comment">// 只能针对post接口的请求参数requestBody进行统一加解密和加签，这是规定</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(<span class="string">&quot;POST&quot;</span>, request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;只能POST接口才能加密加签操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取controller接口方法定义的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        Object[] newArgs = args;</span><br><span class="line">        <span class="type">ApiSecurityParam</span> <span class="variable">apiSecurityParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiSecurityParam</span>();</span><br><span class="line">        <span class="comment">// 请求参数解密</span></span><br><span class="line">        <span class="keyword">if</span> (decryptRequest) &#123;</span><br><span class="line">            <span class="comment">// 不支持多个请求，因为解密请求参数之后会json字符串，再根据请求参数的类型映射过去，如果有多个参数就不知道映射关系了</span></span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;加密接口方法只支持一个参数，请修改&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// args.length=0没有请求参数，就说明没必要解密，因为接口压根不接收参数，即使使用者无脑开启的该接口的参数加密，这里不做任何逻辑即可</span></span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">                RequestBodyWrapper requestBodyWrapper;</span><br><span class="line">                <span class="keyword">if</span> (request <span class="keyword">instanceof</span> RequestBodyWrapper) &#123;</span><br><span class="line">                    requestBodyWrapper = (RequestBodyWrapper) request;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    requestBodyWrapper = <span class="keyword">new</span> <span class="title class_">RequestBodyWrapper</span>(request);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> requestBodyWrapper.getBody();</span><br><span class="line">                apiSecurityParam = JSONObject.parseObject(body, ApiSecurityParam.class);</span><br><span class="line">                <span class="comment">// 通过RSA私钥解密获取到aes秘钥</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">aesKey</span> <span class="operator">=</span> RSAUtil.decryptByPrivateKey(apiSecurityParam.getKey(), apiSecurityProperties.getRsaPrivateKey());</span><br><span class="line">                <span class="comment">// 通过aes秘钥解密data参数数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> AESUtil.decrypt(apiSecurityParam.getData(), aesKey);</span><br><span class="line">                <span class="comment">//获取接口入参的类</span></span><br><span class="line">                Class&lt;?&gt; c = args[<span class="number">0</span>].getClass();</span><br><span class="line">                <span class="comment">//将获取解密后的真实参数，封装到接口入参的类中</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> JSONObject.parseObject(data, c);</span><br><span class="line">                newArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;o&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验签</span></span><br><span class="line">        <span class="keyword">if</span> (isSign) &#123;</span><br><span class="line">            verifySign(request, newArgs.length == <span class="number">0</span> ? <span class="literal">null</span> : newArgs[<span class="number">0</span>], apiSecurityParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed(newArgs);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">verifySign</span><span class="params">(HttpServletRequest request, Object o, ApiSecurityParam apiSecurityParam)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果请求参数是加密传输的，那就先从ApiSecurityParam获取签名和时间戳等等。</span></span><br><span class="line">        <span class="comment">// 如果请求参数不是加密传输的，那么ApiSecurityParam的字段取值都为null，这时候在请求的header里面获取参数信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> apiSecurityParam.getSign();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sign)) &#123;</span><br><span class="line">            sign = request.getHeader(<span class="string">&quot;X-Sign&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(sign)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;签名不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> apiSecurityParam.getNonce();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(nonce)) &#123;</span><br><span class="line">            nonce = request.getHeader(<span class="string">&quot;X-Nonce&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(nonce)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;唯一标识不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> apiSecurityParam.getTimestamp();</span><br><span class="line">        Long t;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(timestamp)) &#123;</span><br><span class="line">            timestamp = request.getHeader(<span class="string">&quot;X-Timestamp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(timestamp)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;时间戳不能为空&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t = Long.valueOf(timestamp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;非法的时间戳&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断timestamp时间戳与当前时间是否超过签名有效时长（过期时间根据业务情况进行配置）,如果超过了就提示签名过期</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - t &gt; apiSecurityProperties.getValidTime()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;签名已过期&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断nonce</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">nonceExists</span> <span class="operator">=</span> stringRedisTemplate.hasKey(NONCE_KEY + nonce);</span><br><span class="line">        <span class="keyword">if</span> (nonceExists) &#123;</span><br><span class="line">            <span class="comment">//请求重复</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;唯一标识nonce已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 验签</span></span><br><span class="line">        <span class="type">SortedMap</span> <span class="variable">sortedMap</span> <span class="operator">=</span> SignUtil.beanToMap(o);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> SignUtil.getContent(sortedMap, nonce, timestamp);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> RSAUtil.verifySignByPublicKey(content, sign, apiSecurityProperties.getRsaPublicKey());</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;签名验证不通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        stringRedisTemplate.opsForValue().set(NONCE_KEY+ nonce, <span class="string">&quot;1&quot;</span>, apiSecurityProperties.getValidTime(),</span><br><span class="line">                TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> ApiSecurity <span class="title function_">getApiSecurity</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line">        <span class="type">ApiSecurity</span> <span class="variable">apiSecurity</span> <span class="operator">=</span> method.getAnnotation(ApiSecurity.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(apiSecurity)) &#123;</span><br><span class="line">            apiSecurity = method.getDeclaringClass().getAnnotation(ApiSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apiSecurity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码没什么好讲的了，就按照上面的加密、加签流程图逻辑实现的，而且注释也很清楚，可以自己慢慢消化，这里面涉及的工具类如 <code>RSAUtil、AESUtil、SignUtil</code> 等，碍于文章代码篇幅，我就这里就在一一展示，我会在文章后面放上全部代码的项目 github 地址以供下载的。</p><p>上面的切面只完成了接口参数的解密和验签，至于对响应参数的加密返回放到了<code>ResponseBodyAdvice</code>中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseResultBodyAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApiSecurityProperties apiSecurityProperties;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类或者方法是否使用了 <span class="doctag">@ResponseResultBody</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseResultBody.class)</span><br><span class="line">                || returnType.hasMethodAnnotation(ResponseResultBody.class)</span><br><span class="line">                || AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ApiSecurity.class)</span><br><span class="line">                || returnType.hasMethodAnnotation(ApiSecurity.class);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当类或者方法使用了 <span class="doctag">@ResponseResultBody</span> 就会调用这个方法</span></span><br><span class="line"><span class="comment">     * 如果返回类型是string，那么springmvc是直接返回的，此时需要手动转化为json</span></span><br><span class="line"><span class="comment">     * 因为当body都为null时，下面的非加密下的if判断参数类型的条件都不满足，如果接口返回类似为String，</span></span><br><span class="line"><span class="comment">     * 会报错com.shepherd.fast.global.ResponseVO cannot be cast to java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> returnType.getMethod();</span><br><span class="line">        Class&lt;?&gt; returnClass = method.getReturnType();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">enable</span> <span class="operator">=</span> apiSecurityProperties.getEnable();</span><br><span class="line">        <span class="type">ApiSecurity</span> <span class="variable">apiSecurity</span> <span class="operator">=</span> method.getAnnotation(ApiSecurity.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(apiSecurity)) &#123;</span><br><span class="line">            apiSecurity = method.getDeclaringClass().getAnnotation(ApiSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (enable &amp;&amp; Objects.nonNull(apiSecurity) &amp;&amp; apiSecurity.encryptResponse() &amp;&amp; Objects.nonNull(body)) &#123;</span><br><span class="line">            <span class="comment">// 只需要加密返回data数据内容</span></span><br><span class="line">            <span class="keyword">if</span> (body <span class="keyword">instanceof</span> ResponseVO) &#123;</span><br><span class="line">                body = ((ResponseVO) body).getData();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> encryptResponse(body);</span><br><span class="line">            body = jsonObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (body <span class="keyword">instanceof</span> String || Objects.equals(returnClass, String.class)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> objectMapper.writeValueAsString(ResponseVO.success(body));</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 防止重复包裹的问题出现</span></span><br><span class="line">            <span class="keyword">if</span> (body <span class="keyword">instanceof</span> ResponseVO) &#123;</span><br><span class="line">                <span class="keyword">return</span> body;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseVO.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    JSONObject <span class="title function_">encryptResponse</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">aseKey</span> <span class="operator">=</span> AESUtil.generateAESKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> JSONObject.toJSONString(result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> AESUtil.encrypt(content, aseKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RSAUtil.encryptByPublicKey(aseKey, apiSecurityProperties.getRsaPublicKey());</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;key&quot;</span>, key);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：shepherd111<br>链接：<a href="https://juejin.cn/post/7230656455806976058">https://juejin.cn/post/7230656455806976058</a><br>来源：稀土掘金<br><strong>Github 地址</strong>：<a href="https://github.com/plasticene/plasticene-boot-starter-parent">plasticene-boot-starter-parent(github.com)</a><br><strong>Gitee地址</strong>：<a href="https://gitee.com/plasticene3/plasticene-boot-starter-parent">plasticene-boot-starter-parent(gitee.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 工具 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB整合到Spring Boot</title>
      <link href="/2023/05/08/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB%E6%95%B4%E5%90%88%E5%88%B0Spring%20Boot/"/>
      <url>/2023/05/08/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB%E6%95%B4%E5%90%88%E5%88%B0Spring%20Boot/</url>
      
        <content type="html"><![CDATA[<h3 id="1-本机测试，使用-Docker-快速搭建-MongoDB："><a href="#1-本机测试，使用-Docker-快速搭建-MongoDB：" class="headerlink" title="1. 本机测试，使用 Docker 快速搭建 MongoDB："></a>1. 本机测试，使用 Docker 快速搭建 MongoDB：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -itd --name mongo -p 27017:27017 mongo --auth</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it mongo mongo admin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 admin，密码为 123456 的用户。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"> db.createUser(&#123; user:<span class="string">&#x27;admin&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;123456&#x27;</span>,roles:[ &#123; role:<span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="string">&#x27;admin&#x27;</span>&#125;,<span class="string">&quot;readWriteAnyDatabase&quot;</span>]&#125;);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试使用上面创建的用户信息进行连接，验证成功返回1。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.auth(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="2-Spring-Boot-导入-mongodb-相关依赖"><a href="#2-Spring-Boot-导入-mongodb-相关依赖" class="headerlink" title="2. Spring Boot 导入 mongodb 相关依赖"></a>2. Spring Boot 导入 mongodb 相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编辑-Spring-Boot-配置文件"><a href="#3-编辑-Spring-Boot-配置文件" class="headerlink" title="3. 编辑 Spring Boot 配置文件"></a>3. 编辑 Spring Boot 配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line"><span class="attr">mongodb:</span>  </span><br><span class="line"><span class="attr">uri:</span> <span class="string">mongodb://admin:123456@localhost:27017/admin</span></span><br></pre></td></tr></table></figure><h3 id="4-基于MongoTemplate-开发CRUD"><a href="#4-基于MongoTemplate-开发CRUD" class="headerlink" title="4. 基于MongoTemplate 开发CRUD"></a>4. 基于MongoTemplate 开发CRUD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;  </span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">alice</span> <span class="operator">=</span> mongoTemplate.insert(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">23</span>));  </span><br><span class="line">System.out.println(alice);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 查询全部  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findAll</span><span class="params">()</span> &#123;  </span><br><span class="line">List&lt;User&gt; all = mongoTemplate.findAll(User.class);  </span><br><span class="line">all.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 根据id查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mongoTemplate.findById(<span class="string">&quot;1&quot;</span>, User.class);  </span><br><span class="line">System.out.println(user);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 根据条件查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findByName</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line">List&lt;User&gt; users = mongoTemplate.find(query, User.class);  </span><br><span class="line">users.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 模糊查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findByNameLike</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).regex(<span class="string">&quot;A&quot;</span>));  </span><br><span class="line">List&lt;User&gt; users = mongoTemplate.find(query, User.class);  </span><br><span class="line">users.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 分页查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">findByNameLikePage</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).regex(<span class="string">&quot;A&quot;</span>));  </span><br><span class="line">query.skip(<span class="number">0</span>).limit(<span class="number">2</span>);  </span><br><span class="line">List&lt;User&gt; users = mongoTemplate.find(query, User.class);  </span><br><span class="line">users.forEach(System.out::println);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 修改  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update1</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mongoTemplate.findOne(query, User.class);  </span><br><span class="line">user.setAge(<span class="number">24</span>);  </span><br><span class="line">mongoTemplate.save(user);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 修改  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update2</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line"><span class="type">Update</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Update</span>();  </span><br><span class="line">update.set(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);  </span><br><span class="line"><span class="type">UpdateResult</span> <span class="variable">upsert</span> <span class="operator">=</span> mongoTemplate.upsert(query, update, User.class);  </span><br><span class="line"><span class="type">long</span> <span class="variable">modifiedCount</span> <span class="operator">=</span> upsert.getModifiedCount();<span class="comment">//获取到修改受影响的行数  </span></span><br><span class="line">System.out.println(<span class="string">&quot;受影响的条数：&quot;</span>+modifiedCount);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 删除  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;Alice&quot;</span>));  </span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">remove</span> <span class="operator">=</span> mongoTemplate.remove(query, User.class);  </span><br><span class="line"><span class="type">long</span> <span class="variable">deletedCount</span> <span class="operator">=</span> remove.getDeletedCount();  </span><br><span class="line">System.out.println(<span class="string">&quot;删除的条数：&quot;</span>+deletedCount);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-基于-MongoRepository-开发-CRUD"><a href="#5-基于-MongoRepository-开发-CRUD" class="headerlink" title="5. 基于 MongoRepository 开发 CRUD"></a>5. 基于 MongoRepository 开发 CRUD</h3><p>Spring Data 提供了对 mongodb 数据访问的支持，我们只需要继承 MongoRepository 类，按照 Spring Data 规范就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;  </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;  </span><br><span class="line"><span class="comment">// 保存  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userRepository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Demon&quot;</span>, <span class="number">21</span>));  </span><br><span class="line">System.out.println(user1);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//查询所有  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findAll</span><span class="params">()</span>&#123;  </span><br><span class="line">List&lt;User&gt; lists = userRepository.findAll();  </span><br><span class="line">lists.forEach(System.out::println); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//根据id查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(<span class="string">&quot;2&quot;</span>).get();  </span><br><span class="line">System.out.println(user);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//条件查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserList</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">user.setName(<span class="string">&quot;Demon&quot;</span>);  </span><br><span class="line">user.setAge(<span class="number">21</span>);  </span><br><span class="line">Example&lt;User&gt; example = Example.of(user);  </span><br><span class="line">List&lt;User&gt; all = userRepository.findAll(example);  </span><br><span class="line">System.out.println(all);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//模糊条件查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findLikeUserList</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">///创建匹配器，即如何使用查询条件  </span></span><br><span class="line"><span class="type">ExampleMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> ExampleMatcher.matching()<span class="comment">//构建对象  </span></span><br><span class="line">.withStringMatcher(ExampleMatcher.StringMatcher.STARTING)<span class="comment">//改变默认字符串匹配方式：模糊查询  </span></span><br><span class="line">.withIgnoreCase(<span class="literal">true</span>);<span class="comment">//改变默认大小写忽略方式：忽略大小写  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">user.setName(<span class="string">&quot;De&quot;</span>);  </span><br><span class="line">user.setAge(<span class="number">21</span>);  </span><br><span class="line">Example&lt;User&gt; example = Example.of(user, matcher);  </span><br><span class="line">List&lt;User&gt; all = userRepository.findAll(example);  </span><br><span class="line">System.out.println(all);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//分页查询  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPageUserAll</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">//设置分页参数  </span></span><br><span class="line"><span class="comment">//0代表第一页  </span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">3</span>);  </span><br><span class="line"><span class="comment">//查询条件  </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">user.setName(<span class="string">&quot;Demon&quot;</span>);  </span><br><span class="line">user.setAge(<span class="number">21</span>);  </span><br><span class="line">Example&lt;User&gt; userExample = Example.of(user);<span class="comment">//查询条件  </span></span><br><span class="line">Page&lt;User&gt; page = userRepository.findAll(userExample, pageable);  </span><br><span class="line">System.out.println(page.getContent());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//修改操作  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">//先根据id出要修改的用户  </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(<span class="string">&quot;2&quot;</span>).get();  </span><br><span class="line"><span class="comment">//设置修改的值  </span></span><br><span class="line">user.setAge(<span class="number">24</span>);  </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userRepository.save(user);  </span><br><span class="line">System.out.println(user1);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//删除  </span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;  </span><br><span class="line">userRepository.deleteById(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Configuration和@Component 区别</title>
      <link href="/2023/05/08/%E5%90%8E%E7%AB%AF/Spring/@Configuration%E5%92%8C@Component%20%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/05/08/%E5%90%8E%E7%AB%AF/Spring/@Configuration%E5%92%8C@Component%20%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在@Component 类中使用方法或字段时不会使用 CGLIB 增强 (及不使用代理类：调用任何方法，使用任何变量，拿到的是原始对象，后面会有例子解释)。在@Component 中调用@Bean 注解的方法和字段则是普通的 Java 语义，不经过 CGLIB 处理。<br>而在@Configuration 类中使用方法或字段时则使用 CGLIB 创造协作对象（及使用代理：拿到的是代理对象）; 当调用@Bean 注解的方法时它不是普通的 Java 语义，而是从容器中拿到由 Spring 生命周期管理、被 Spring 代理甚至依赖于其他 Bean 的对象引用。</p></blockquote><p>@Configuration 本质上还是个@Component，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>  </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  </span><br><span class="line"><span class="meta">@Documented</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span>  </span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 中，对于配置类来讲是有分类的，大体可以分为两类，<strong>一类称为 LITE 模式，另一类称为 FULL 模式</strong>，那么对应上面的注解，@Component 就是 LITE 类型，@Configuration 就是 FULL 类型。</p><p><a href="https://zhuanlan.zhihu.com/p/607801167">Spring注解配置：@Configuration 和 @Component 区别及原理详解 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="/2023/04/26/%E6%9D%82%E9%A1%B9/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/04/26/%E6%9D%82%E9%A1%B9/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>hexo 官网：<a href="https://hexo.io/zh-cn/index.html">Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
